
MCP2515.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b36  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00007b36  00000bca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000030  00800076  00800076  00000be0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000be0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000c10  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000228  00000000  00000000  00000c50  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000027ae  00000000  00000000  00000e78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ca7  00000000  00000000  00003626  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000012da  00000000  00000000  000042cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000558  00000000  00000000  000055a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b23  00000000  00000000  00005b00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001856  00000000  00000000  00006623  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  00007e79  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 2a 38 	jmp	0x7054	; 0x7054 <__ctors_end>
    7004:	0c 94 ce 3a 	jmp	0x759c	; 0x759c <__vector_1>
    7008:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    700c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7010:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7014:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7018:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    701c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7020:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7024:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7028:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    702c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7030:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7034:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7038:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    703c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7040:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7044:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7048:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    704c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7050:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>

00007054 <__ctors_end>:
    7054:	11 24       	eor	r1, r1
    7056:	1f be       	out	0x3f, r1	; 63
    7058:	cf e5       	ldi	r28, 0x5F	; 95
    705a:	d8 e0       	ldi	r29, 0x08	; 8
    705c:	de bf       	out	0x3e, r29	; 62
    705e:	cd bf       	out	0x3d, r28	; 61

00007060 <__do_copy_data>:
    7060:	10 e0       	ldi	r17, 0x00	; 0
    7062:	a0 e6       	ldi	r26, 0x60	; 96
    7064:	b0 e0       	ldi	r27, 0x00	; 0
    7066:	e6 e3       	ldi	r30, 0x36	; 54
    7068:	fb e7       	ldi	r31, 0x7B	; 123
    706a:	02 c0       	rjmp	.+4      	; 0x7070 <__do_copy_data+0x10>
    706c:	05 90       	lpm	r0, Z+
    706e:	0d 92       	st	X+, r0
    7070:	a6 37       	cpi	r26, 0x76	; 118
    7072:	b1 07       	cpc	r27, r17
    7074:	d9 f7       	brne	.-10     	; 0x706c <__do_copy_data+0xc>

00007076 <__do_clear_bss>:
    7076:	20 e0       	ldi	r18, 0x00	; 0
    7078:	a6 e7       	ldi	r26, 0x76	; 118
    707a:	b0 e0       	ldi	r27, 0x00	; 0
    707c:	01 c0       	rjmp	.+2      	; 0x7080 <.do_clear_bss_start>

0000707e <.do_clear_bss_loop>:
    707e:	1d 92       	st	X+, r1

00007080 <.do_clear_bss_start>:
    7080:	a6 3a       	cpi	r26, 0xA6	; 166
    7082:	b2 07       	cpc	r27, r18
    7084:	e1 f7       	brne	.-8      	; 0x707e <.do_clear_bss_loop>
    7086:	0e 94 27 3a 	call	0x744e	; 0x744e <main>
    708a:	0c 94 99 3d 	jmp	0x7b32	; 0x7b32 <_exit>

0000708e <__bad_interrupt>:
    708e:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

00007092 <HAL_GPIO_INIT_PIN>:
	}
	else
	{
		return GPIO_PIN_RESET ;
	}
}
    7092:	dc 01       	movw	r26, r24
    7094:	fb 01       	movw	r30, r22
    7096:	81 81       	ldd	r24, Z+1	; 0x01
    7098:	81 30       	cpi	r24, 0x01	; 1
    709a:	99 f4       	brne	.+38     	; 0x70c2 <HAL_GPIO_INIT_PIN+0x30>
    709c:	80 81       	ld	r24, Z
    709e:	11 96       	adiw	r26, 0x01	; 1
    70a0:	9c 91       	ld	r25, X
    70a2:	11 97       	sbiw	r26, 0x01	; 1
    70a4:	89 2b       	or	r24, r25
    70a6:	11 96       	adiw	r26, 0x01	; 1
    70a8:	8c 93       	st	X, r24
    70aa:	11 97       	sbiw	r26, 0x01	; 1
    70ac:	82 81       	ldd	r24, Z+2	; 0x02
    70ae:	81 30       	cpi	r24, 0x01	; 1
    70b0:	81 f4       	brne	.+32     	; 0x70d2 <HAL_GPIO_INIT_PIN+0x40>
    70b2:	80 81       	ld	r24, Z
    70b4:	12 96       	adiw	r26, 0x02	; 2
    70b6:	9c 91       	ld	r25, X
    70b8:	12 97       	sbiw	r26, 0x02	; 2
    70ba:	89 2b       	or	r24, r25
    70bc:	12 96       	adiw	r26, 0x02	; 2
    70be:	8c 93       	st	X, r24
    70c0:	08 95       	ret
    70c2:	90 81       	ld	r25, Z
    70c4:	90 95       	com	r25
    70c6:	11 96       	adiw	r26, 0x01	; 1
    70c8:	8c 91       	ld	r24, X
    70ca:	11 97       	sbiw	r26, 0x01	; 1
    70cc:	98 23       	and	r25, r24
    70ce:	11 96       	adiw	r26, 0x01	; 1
    70d0:	9c 93       	st	X, r25
    70d2:	08 95       	ret

000070d4 <HAL_GPIO_WRITEPIN>:

void HAL_GPIO_WRITEPIN(GPIO_TypeDef * PORT,uint8_t PIN_NUM,GPIO_PinState PIN_STATE)
{
	if(PIN_STATE != GPIO_PIN_RESET)
    70d4:	44 23       	and	r20, r20
    70d6:	29 f0       	breq	.+10     	; 0x70e2 <HAL_GPIO_WRITEPIN+0xe>
	{
		PORT->PORT_REG |= PIN_NUM ;
    70d8:	fc 01       	movw	r30, r24
    70da:	22 81       	ldd	r18, Z+2	; 0x02
    70dc:	62 2b       	or	r22, r18
    70de:	62 83       	std	Z+2, r22	; 0x02
    70e0:	08 95       	ret
	}
	else
	{
		PORT->PORT_REG &= ~(PIN_NUM);
    70e2:	60 95       	com	r22
    70e4:	fc 01       	movw	r30, r24
    70e6:	22 81       	ldd	r18, Z+2	; 0x02
    70e8:	62 23       	and	r22, r18
    70ea:	62 83       	std	Z+2, r22	; 0x02
    70ec:	08 95       	ret

000070ee <HAL_GPIO_WRITEPORT>:
	}
	
}

void HAL_GPIO_WRITEPORT(GPIO_TypeDef * PORT,uint8_t PINS,GPIO_PinState PINS_STATE)
{
    70ee:	fc 01       	movw	r30, r24
	PORT->PORT_REG &=~(PINS);
    70f0:	60 95       	com	r22
    70f2:	92 81       	ldd	r25, Z+2	; 0x02
    70f4:	69 23       	and	r22, r25
	PORT->PORT_REG |=(PINS_STATE);
    70f6:	46 2b       	or	r20, r22
    70f8:	42 83       	std	Z+2, r20	; 0x02
    70fa:	08 95       	ret

000070fc <HAL_SPI_Init>:
		while(!(SPI_PREPH->SPI_SPSR & SPI_SPSR_SPIF));  /* wait till the spi send byte and set SPIIF bit */
		++(Handler->RxBuffer);
		--(Handler->RxBufferSize);
	}	
	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_SET);	
}/* END_FUN HAL_SPI_Recieve()*/
    70fc:	0f 93       	push	r16
    70fe:	1f 93       	push	r17
    7100:	cf 93       	push	r28
    7102:	df 93       	push	r29
    7104:	00 d0       	rcall	.+0      	; 0x7106 <HAL_SPI_Init+0xa>
    7106:	1f 92       	push	r1
    7108:	cd b7       	in	r28, 0x3d	; 61
    710a:	de b7       	in	r29, 0x3e	; 62
    710c:	8c 01       	movw	r16, r24
    710e:	fc 01       	movw	r30, r24
    7110:	83 81       	ldd	r24, Z+3	; 0x03
    7112:	88 23       	and	r24, r24
    7114:	44 f4       	brge	.+16     	; 0x7126 <HAL_SPI_Init+0x2a>
    7116:	9d b1       	in	r25, 0x0d	; 13
    7118:	83 70       	andi	r24, 0x03	; 3
    711a:	89 2b       	or	r24, r25
    711c:	8d b9       	out	0x0d, r24	; 13
    711e:	8e b1       	in	r24, 0x0e	; 14
    7120:	81 60       	ori	r24, 0x01	; 1
    7122:	8e b9       	out	0x0e, r24	; 14
    7124:	04 c0       	rjmp	.+8      	; 0x712e <HAL_SPI_Init+0x32>
    7126:	9d b1       	in	r25, 0x0d	; 13
    7128:	83 70       	andi	r24, 0x03	; 3
    712a:	89 2b       	or	r24, r25
    712c:	8d b9       	out	0x0d, r24	; 13
    712e:	f8 01       	movw	r30, r16
    7130:	80 81       	ld	r24, Z
    7132:	84 ff       	sbrs	r24, 4
    7134:	16 c0       	rjmp	.+44     	; 0x7162 <HAL_SPI_Init+0x66>
    7136:	81 e0       	ldi	r24, 0x01	; 1
    7138:	8a 83       	std	Y+2, r24	; 0x02
    713a:	80 eb       	ldi	r24, 0xB0	; 176
    713c:	89 83       	std	Y+1, r24	; 0x01
    713e:	be 01       	movw	r22, r28
    7140:	6f 5f       	subi	r22, 0xFF	; 255
    7142:	7f 4f       	sbci	r23, 0xFF	; 255
    7144:	86 e3       	ldi	r24, 0x36	; 54
    7146:	90 e0       	ldi	r25, 0x00	; 0
    7148:	0e 94 49 38 	call	0x7092	; 0x7092 <HAL_GPIO_INIT_PIN>
    714c:	1a 82       	std	Y+2, r1	; 0x02
    714e:	80 e4       	ldi	r24, 0x40	; 64
    7150:	89 83       	std	Y+1, r24	; 0x01
    7152:	be 01       	movw	r22, r28
    7154:	6f 5f       	subi	r22, 0xFF	; 255
    7156:	7f 4f       	sbci	r23, 0xFF	; 255
    7158:	86 e3       	ldi	r24, 0x36	; 54
    715a:	90 e0       	ldi	r25, 0x00	; 0
    715c:	0e 94 49 38 	call	0x7092	; 0x7092 <HAL_GPIO_INIT_PIN>
    7160:	15 c0       	rjmp	.+42     	; 0x718c <HAL_SPI_Init+0x90>
    7162:	1a 82       	std	Y+2, r1	; 0x02
    7164:	80 eb       	ldi	r24, 0xB0	; 176
    7166:	89 83       	std	Y+1, r24	; 0x01
    7168:	be 01       	movw	r22, r28
    716a:	6f 5f       	subi	r22, 0xFF	; 255
    716c:	7f 4f       	sbci	r23, 0xFF	; 255
    716e:	86 e3       	ldi	r24, 0x36	; 54
    7170:	90 e0       	ldi	r25, 0x00	; 0
    7172:	0e 94 49 38 	call	0x7092	; 0x7092 <HAL_GPIO_INIT_PIN>
    7176:	81 e0       	ldi	r24, 0x01	; 1
    7178:	8a 83       	std	Y+2, r24	; 0x02
    717a:	80 e4       	ldi	r24, 0x40	; 64
    717c:	89 83       	std	Y+1, r24	; 0x01
    717e:	be 01       	movw	r22, r28
    7180:	6f 5f       	subi	r22, 0xFF	; 255
    7182:	7f 4f       	sbci	r23, 0xFF	; 255
    7184:	86 e3       	ldi	r24, 0x36	; 54
    7186:	90 e0       	ldi	r25, 0x00	; 0
    7188:	0e 94 49 38 	call	0x7092	; 0x7092 <HAL_GPIO_INIT_PIN>
    718c:	f8 01       	movw	r30, r16
    718e:	42 81       	ldd	r20, Z+2	; 0x02
    7190:	81 81       	ldd	r24, Z+1	; 0x01
    7192:	34 81       	ldd	r19, Z+4	; 0x04
    7194:	25 81       	ldd	r18, Z+5	; 0x05
    7196:	90 81       	ld	r25, Z
    7198:	84 2b       	or	r24, r20
    719a:	83 2b       	or	r24, r19
    719c:	82 2b       	or	r24, r18
    719e:	89 2b       	or	r24, r25
    71a0:	8d b9       	out	0x0d, r24	; 13
    71a2:	8d b1       	in	r24, 0x0d	; 13
    71a4:	80 64       	ori	r24, 0x40	; 64
    71a6:	8d b9       	out	0x0d, r24	; 13
    71a8:	85 81       	ldd	r24, Z+5	; 0x05
    71aa:	80 38       	cpi	r24, 0x80	; 128
    71ac:	09 f4       	brne	.+2      	; 0x71b0 <HAL_SPI_Init+0xb4>
    71ae:	78 94       	sei
    71b0:	0f 90       	pop	r0
    71b2:	0f 90       	pop	r0
    71b4:	0f 90       	pop	r0
    71b6:	df 91       	pop	r29
    71b8:	cf 91       	pop	r28
    71ba:	1f 91       	pop	r17
    71bc:	0f 91       	pop	r16
    71be:	08 95       	ret

000071c0 <HAL_SPI_Transmit>:
    71c0:	cf 93       	push	r28
    71c2:	df 93       	push	r29
    71c4:	ec 01       	movw	r28, r24
    71c6:	19 86       	std	Y+9, r1	; 0x09
    71c8:	18 86       	std	Y+8, r1	; 0x08
    71ca:	1d 86       	std	Y+13, r1	; 0x0d
    71cc:	1c 86       	std	Y+12, r1	; 0x0c
    71ce:	7f 83       	std	Y+7, r23	; 0x07
    71d0:	6e 83       	std	Y+6, r22	; 0x06
    71d2:	5b 87       	std	Y+11, r21	; 0x0b
    71d4:	4a 87       	std	Y+10, r20	; 0x0a
    71d6:	40 e0       	ldi	r20, 0x00	; 0
    71d8:	60 e1       	ldi	r22, 0x10	; 16
    71da:	86 e3       	ldi	r24, 0x36	; 54
    71dc:	90 e0       	ldi	r25, 0x00	; 0
    71de:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
    71e2:	0b c0       	rjmp	.+22     	; 0x71fa <HAL_SPI_Transmit+0x3a>
    71e4:	ee 81       	ldd	r30, Y+6	; 0x06
    71e6:	ff 81       	ldd	r31, Y+7	; 0x07
    71e8:	80 81       	ld	r24, Z
    71ea:	8f b9       	out	0x0f, r24	; 15
    71ec:	77 9b       	sbis	0x0e, 7	; 14
    71ee:	fe cf       	rjmp	.-4      	; 0x71ec <HAL_SPI_Transmit+0x2c>
    71f0:	8e 81       	ldd	r24, Y+6	; 0x06
    71f2:	9f 81       	ldd	r25, Y+7	; 0x07
    71f4:	01 96       	adiw	r24, 0x01	; 1
    71f6:	9f 83       	std	Y+7, r25	; 0x07
    71f8:	8e 83       	std	Y+6, r24	; 0x06
    71fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    71fc:	9b 85       	ldd	r25, Y+11	; 0x0b
    71fe:	9c 01       	movw	r18, r24
    7200:	21 50       	subi	r18, 0x01	; 1
    7202:	31 09       	sbc	r19, r1
    7204:	3b 87       	std	Y+11, r19	; 0x0b
    7206:	2a 87       	std	Y+10, r18	; 0x0a
    7208:	89 2b       	or	r24, r25
    720a:	61 f7       	brne	.-40     	; 0x71e4 <HAL_SPI_Transmit+0x24>
    720c:	41 e0       	ldi	r20, 0x01	; 1
    720e:	60 e1       	ldi	r22, 0x10	; 16
    7210:	86 e3       	ldi	r24, 0x36	; 54
    7212:	90 e0       	ldi	r25, 0x00	; 0
    7214:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
    7218:	df 91       	pop	r29
    721a:	cf 91       	pop	r28
    721c:	08 95       	ret

0000721e <HAL_SPI_TransmitRecive>:
 * param. : pTxData --> pointer to the Tx buffer 
 * param. : pRxData --> pointer to the rx buffer
 * param. : size : the required number of bytes to received and transmit 
*/
 void HAL_SPI_TransmitRecive(SPI_Handler_t * Handler,uint8_t * pTxData,uint8_t * pRxData,uint16_t size )
{
    721e:	cf 93       	push	r28
    7220:	df 93       	push	r29
    7222:	ec 01       	movw	r28, r24
	Handler->RxBuffer = pRxData ;
    7224:	59 87       	std	Y+9, r21	; 0x09
    7226:	48 87       	std	Y+8, r20	; 0x08
	Handler->TxBuffer = pTxData  ;
    7228:	7f 83       	std	Y+7, r23	; 0x07
    722a:	6e 83       	std	Y+6, r22	; 0x06
	Handler->RxBufferSize = size ;
    722c:	3d 87       	std	Y+13, r19	; 0x0d
    722e:	2c 87       	std	Y+12, r18	; 0x0c
	Handler->TxBufferSize = size;
    7230:	3b 87       	std	Y+11, r19	; 0x0b
    7232:	2a 87       	std	Y+10, r18	; 0x0a

	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_RESET);
    7234:	40 e0       	ldi	r20, 0x00	; 0
    7236:	60 e1       	ldi	r22, 0x10	; 16
    7238:	86 e3       	ldi	r24, 0x36	; 54
    723a:	90 e0       	ldi	r25, 0x00	; 0
    723c:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>

	while(Handler->RxBufferSize-- > 0)  /* block till end operation */
    7240:	14 c0       	rjmp	.+40     	; 0x726a <HAL_SPI_TransmitRecive+0x4c>
	{

		SPI_PREPH->SPI_SPDR = *(Handler->TxBuffer);
    7242:	ee 81       	ldd	r30, Y+6	; 0x06
    7244:	ff 81       	ldd	r31, Y+7	; 0x07
    7246:	80 81       	ld	r24, Z
    7248:	8f b9       	out	0x0f, r24	; 15
		while(!(SPI_PREPH->SPI_SPSR & SPI_SPSR_SPIF));  /* wait till the SPI send byte and set SPIIF bit */
    724a:	77 9b       	sbis	0x0e, 7	; 14
    724c:	fe cf       	rjmp	.-4      	; 0x724a <HAL_SPI_TransmitRecive+0x2c>
		*(Handler->RxBuffer) = SPI_PREPH->SPI_SPDR ;
    724e:	e8 85       	ldd	r30, Y+8	; 0x08
    7250:	f9 85       	ldd	r31, Y+9	; 0x09
    7252:	8f b1       	in	r24, 0x0f	; 15
    7254:	80 83       	st	Z, r24
		++(Handler->RxBuffer);
    7256:	88 85       	ldd	r24, Y+8	; 0x08
    7258:	99 85       	ldd	r25, Y+9	; 0x09
    725a:	01 96       	adiw	r24, 0x01	; 1
    725c:	99 87       	std	Y+9, r25	; 0x09
    725e:	88 87       	std	Y+8, r24	; 0x08
		++(Handler->TxBuffer);
    7260:	8e 81       	ldd	r24, Y+6	; 0x06
    7262:	9f 81       	ldd	r25, Y+7	; 0x07
    7264:	01 96       	adiw	r24, 0x01	; 1
    7266:	9f 83       	std	Y+7, r25	; 0x07
    7268:	8e 83       	std	Y+6, r24	; 0x06
	Handler->RxBufferSize = size ;
	Handler->TxBufferSize = size;

	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_RESET);

	while(Handler->RxBufferSize-- > 0)  /* block till end operation */
    726a:	8c 85       	ldd	r24, Y+12	; 0x0c
    726c:	9d 85       	ldd	r25, Y+13	; 0x0d
    726e:	9c 01       	movw	r18, r24
    7270:	21 50       	subi	r18, 0x01	; 1
    7272:	31 09       	sbc	r19, r1
    7274:	3d 87       	std	Y+13, r19	; 0x0d
    7276:	2c 87       	std	Y+12, r18	; 0x0c
    7278:	89 2b       	or	r24, r25
    727a:	19 f7       	brne	.-58     	; 0x7242 <HAL_SPI_TransmitRecive+0x24>
		*(Handler->RxBuffer) = SPI_PREPH->SPI_SPDR ;
		++(Handler->RxBuffer);
		++(Handler->TxBuffer);
		
	}	
	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_SET);
    727c:	41 e0       	ldi	r20, 0x01	; 1
    727e:	60 e1       	ldi	r22, 0x10	; 16
    7280:	86 e3       	ldi	r24, 0x36	; 54
    7282:	90 e0       	ldi	r25, 0x00	; 0
    7284:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
	
}/* END_FUN HAL_TransmitRecive()*/
    7288:	df 91       	pop	r29
    728a:	cf 91       	pop	r28
    728c:	08 95       	ret

0000728e <LCD_Triger_Enable>:
	LCD_Goto_Location(y,x);
	HAL_GPIO_WRITEPIN(GPIOB,LCD_RS_GPIOB,GPIO_PIN_SET);
	HAL_GPIO_WRITEPIN(GPIOB,LCD_RW_GPIOB,GPIO_PIN_RESET);
	LCD_Send_4BitData(ch);
	
}
    728e:	41 e0       	ldi	r20, 0x01	; 1
    7290:	68 e0       	ldi	r22, 0x08	; 8
    7292:	86 e3       	ldi	r24, 0x36	; 54
    7294:	90 e0       	ldi	r25, 0x00	; 0
    7296:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
    729a:	85 e0       	ldi	r24, 0x05	; 5
    729c:	8a 95       	dec	r24
    729e:	f1 f7       	brne	.-4      	; 0x729c <LCD_Triger_Enable+0xe>
    72a0:	00 00       	nop
    72a2:	40 e0       	ldi	r20, 0x00	; 0
    72a4:	68 e0       	ldi	r22, 0x08	; 8
    72a6:	86 e3       	ldi	r24, 0x36	; 54
    72a8:	90 e0       	ldi	r25, 0x00	; 0
    72aa:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
    72ae:	8f e3       	ldi	r24, 0x3F	; 63
    72b0:	9f e1       	ldi	r25, 0x1F	; 31
    72b2:	01 97       	sbiw	r24, 0x01	; 1
    72b4:	f1 f7       	brne	.-4      	; 0x72b2 <LCD_Triger_Enable+0x24>
    72b6:	00 c0       	rjmp	.+0      	; 0x72b8 <LCD_Triger_Enable+0x2a>
    72b8:	00 00       	nop
    72ba:	08 95       	ret

000072bc <LCD_Send_4BitData>:
    72bc:	cf 93       	push	r28
    72be:	c8 2f       	mov	r28, r24
    72c0:	48 2f       	mov	r20, r24
    72c2:	40 7f       	andi	r20, 0xF0	; 240
    72c4:	60 ef       	ldi	r22, 0xF0	; 240
    72c6:	89 e3       	ldi	r24, 0x39	; 57
    72c8:	90 e0       	ldi	r25, 0x00	; 0
    72ca:	0e 94 77 38 	call	0x70ee	; 0x70ee <HAL_GPIO_WRITEPORT>
    72ce:	0e 94 47 39 	call	0x728e	; 0x728e <LCD_Triger_Enable>
    72d2:	80 e1       	ldi	r24, 0x10	; 16
    72d4:	c8 9f       	mul	r28, r24
    72d6:	a0 01       	movw	r20, r0
    72d8:	11 24       	eor	r1, r1
    72da:	60 ef       	ldi	r22, 0xF0	; 240
    72dc:	89 e3       	ldi	r24, 0x39	; 57
    72de:	90 e0       	ldi	r25, 0x00	; 0
    72e0:	0e 94 77 38 	call	0x70ee	; 0x70ee <HAL_GPIO_WRITEPORT>
    72e4:	0e 94 47 39 	call	0x728e	; 0x728e <LCD_Triger_Enable>
    72e8:	cf 91       	pop	r28
    72ea:	08 95       	ret

000072ec <LCD_Send_A_Character_With_CurrLoc>:
    72ec:	cf 93       	push	r28
    72ee:	c8 2f       	mov	r28, r24
    72f0:	41 e0       	ldi	r20, 0x01	; 1
    72f2:	62 e0       	ldi	r22, 0x02	; 2
    72f4:	86 e3       	ldi	r24, 0x36	; 54
    72f6:	90 e0       	ldi	r25, 0x00	; 0
    72f8:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
    72fc:	40 e0       	ldi	r20, 0x00	; 0
    72fe:	64 e0       	ldi	r22, 0x04	; 4
    7300:	86 e3       	ldi	r24, 0x36	; 54
    7302:	90 e0       	ldi	r25, 0x00	; 0
    7304:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
    7308:	8c 2f       	mov	r24, r28
    730a:	0e 94 5e 39 	call	0x72bc	; 0x72bc <LCD_Send_4BitData>
    730e:	cf 91       	pop	r28
    7310:	08 95       	ret

00007312 <LCD_Send_A_Command>:
    7312:	cf 93       	push	r28
    7314:	c8 2f       	mov	r28, r24
    7316:	40 e0       	ldi	r20, 0x00	; 0
    7318:	66 e0       	ldi	r22, 0x06	; 6
    731a:	86 e3       	ldi	r24, 0x36	; 54
    731c:	90 e0       	ldi	r25, 0x00	; 0
    731e:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <HAL_GPIO_WRITEPIN>
    7322:	8c 2f       	mov	r24, r28
    7324:	0e 94 5e 39 	call	0x72bc	; 0x72bc <LCD_Send_4BitData>
    7328:	cf 91       	pop	r28
    732a:	08 95       	ret

0000732c <LCD_Goto_Location>:
    732c:	e8 2f       	mov	r30, r24
    732e:	f0 e0       	ldi	r31, 0x00	; 0
    7330:	e1 5a       	subi	r30, 0xA1	; 161
    7332:	ff 4f       	sbci	r31, 0xFF	; 255
    7334:	80 81       	ld	r24, Z
    7336:	86 0f       	add	r24, r22
    7338:	81 50       	subi	r24, 0x01	; 1
    733a:	0e 94 89 39 	call	0x7312	; 0x7312 <LCD_Send_A_Command>
    733e:	08 95       	ret

00007340 <LCD_Initializaion>:
	LCD_Send_A_Command(column_position[y-1]+(x-1));
}


void LCD_Initializaion(void)
{
    7340:	cf 93       	push	r28
    7342:	df 93       	push	r29
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    7344:	2f ef       	ldi	r18, 0xFF	; 255
    7346:	89 ef       	ldi	r24, 0xF9	; 249
    7348:	90 e0       	ldi	r25, 0x00	; 0
    734a:	21 50       	subi	r18, 0x01	; 1
    734c:	80 40       	sbci	r24, 0x00	; 0
    734e:	90 40       	sbci	r25, 0x00	; 0
    7350:	e1 f7       	brne	.-8      	; 0x734a <LCD_Initializaion+0xa>
    7352:	00 c0       	rjmp	.+0      	; 0x7354 <LCD_Initializaion+0x14>
    7354:	00 00       	nop
	_delay_ms(20);
	// initialize portB pin 1,2,3 as output
	LCD_GPIO_Handler.mode = GPIO_MODE_OUTPUT ;
    7356:	c6 e7       	ldi	r28, 0x76	; 118
    7358:	d0 e0       	ldi	r29, 0x00	; 0
    735a:	81 e0       	ldi	r24, 0x01	; 1
    735c:	89 83       	std	Y+1, r24	; 0x01
	LCD_GPIO_Handler.pinS = LCD_RW_GPIOB |LCD_RS_GPIOB |LCD_EN_GPIOB ;
    735e:	8e e0       	ldi	r24, 0x0E	; 14
    7360:	88 83       	st	Y, r24
	LCD_GPIO_Handler.pull =GPIO_NOPULL ;
    7362:	1a 82       	std	Y+2, r1	; 0x02
	HAL_GPIO_INIT_PIN(GPIOB,&LCD_GPIO_Handler);
    7364:	be 01       	movw	r22, r28
    7366:	86 e3       	ldi	r24, 0x36	; 54
    7368:	90 e0       	ldi	r25, 0x00	; 0
    736a:	0e 94 49 38 	call	0x7092	; 0x7092 <HAL_GPIO_INIT_PIN>
	
	// initialize portA pin 4,5,6,7 as output	
	LCD_GPIO_Handler.pinS = LCD_D4_GPIOA|LCD_D5_GPIOA|LCD_D6_GPIOA|LCD_D7_GPIOA;
    736e:	80 ef       	ldi	r24, 0xF0	; 240
    7370:	88 83       	st	Y, r24
	HAL_GPIO_INIT_PIN(GPIOA,&LCD_GPIO_Handler);
    7372:	be 01       	movw	r22, r28
    7374:	89 e3       	ldi	r24, 0x39	; 57
    7376:	90 e0       	ldi	r25, 0x00	; 0
    7378:	0e 94 49 38 	call	0x7092	; 0x7092 <HAL_GPIO_INIT_PIN>

	LCD_Send_A_Command(0x33U); // LCD initialization command 
    737c:	83 e3       	ldi	r24, 0x33	; 51
    737e:	0e 94 89 39 	call	0x7312	; 0x7312 <LCD_Send_A_Command>
	LCD_Send_A_Command(0x32U);
    7382:	82 e3       	ldi	r24, 0x32	; 50
    7384:	0e 94 89 39 	call	0x7312	; 0x7312 <LCD_Send_A_Command>
	LCD_Send_A_Command(LCD_2LINE_4_BIT_MODE);
    7388:	88 e2       	ldi	r24, 0x28	; 40
    738a:	0e 94 89 39 	call	0x7312	; 0x7312 <LCD_Send_A_Command>
	LCD_Send_A_Command(LCD_COMMANED_CLEAR_CURSOR_OFF);
    738e:	8c e0       	ldi	r24, 0x0C	; 12
    7390:	0e 94 89 39 	call	0x7312	; 0x7312 <LCD_Send_A_Command>
	LCD_Send_A_Command(LCD_COMMANED_CLEAR_LCD);
    7394:	81 e0       	ldi	r24, 0x01	; 1
    7396:	0e 94 89 39 	call	0x7312	; 0x7312 <LCD_Send_A_Command>
	
}
    739a:	df 91       	pop	r29
    739c:	cf 91       	pop	r28
    739e:	08 95       	ret

000073a0 <LCD_Send_A_String_WithLoc>:

void LCD_Send_A_String_WithLoc(uint8_t y, uint8_t x, uint8_t *StringOfCharacters)
{
    73a0:	cf 93       	push	r28
    73a2:	df 93       	push	r29
    73a4:	ea 01       	movw	r28, r20
	LCD_Goto_Location(y,x);
    73a6:	0e 94 96 39 	call	0x732c	; 0x732c <LCD_Goto_Location>
	while (*StringOfCharacters != 0)
    73aa:	03 c0       	rjmp	.+6      	; 0x73b2 <LCD_Send_A_String_WithLoc+0x12>
	{
		LCD_Send_A_Character_With_CurrLoc(*StringOfCharacters++);
    73ac:	21 96       	adiw	r28, 0x01	; 1
    73ae:	0e 94 76 39 	call	0x72ec	; 0x72ec <LCD_Send_A_Character_With_CurrLoc>
}

void LCD_Send_A_String_WithLoc(uint8_t y, uint8_t x, uint8_t *StringOfCharacters)
{
	LCD_Goto_Location(y,x);
	while (*StringOfCharacters != 0)
    73b2:	88 81       	ld	r24, Y
    73b4:	81 11       	cpse	r24, r1
    73b6:	fa cf       	rjmp	.-12     	; 0x73ac <LCD_Send_A_String_WithLoc+0xc>
	{
		LCD_Send_A_Character_With_CurrLoc(*StringOfCharacters++);
	}
}
    73b8:	df 91       	pop	r29
    73ba:	cf 91       	pop	r28
    73bc:	08 95       	ret

000073be <LCD_Send_An_Integer_WithLoc>:

void LCD_Send_An_Integer_WithLoc(uint8_t y, uint8_t x, uint16_t IntegerToDisplay, uint8_t NumberOfDigits)
{
    73be:	8f 92       	push	r8
    73c0:	9f 92       	push	r9
    73c2:	af 92       	push	r10
    73c4:	bf 92       	push	r11
    73c6:	cf 92       	push	r12
    73c8:	df 92       	push	r13
    73ca:	ef 92       	push	r14
    73cc:	ff 92       	push	r15
    73ce:	0f 93       	push	r16
    73d0:	1f 93       	push	r17
    73d2:	cf 93       	push	r28
    73d4:	df 93       	push	r29
    73d6:	cd b7       	in	r28, 0x3d	; 61
    73d8:	de b7       	in	r29, 0x3e	; 62
    73da:	98 2e       	mov	r9, r24
    73dc:	86 2e       	mov	r8, r22
    73de:	ca 01       	movw	r24, r20
	itoa(IntegerToDisplay,StringToDisplay,10);
	for (uint16_t i=0;i<NumberOfDigits;i++)
	LCD_Send_A_Character_With_CurrLoc(' ');
	
	LCD_Send_A_String_WithLoc(y,x,StringToDisplay);
}
    73e0:	ad b6       	in	r10, 0x3d	; 61
    73e2:	be b6       	in	r11, 0x3e	; 62
	}
}

void LCD_Send_An_Integer_WithLoc(uint8_t y, uint8_t x, uint16_t IntegerToDisplay, uint8_t NumberOfDigits)
{
	uint8_t StringToDisplay[NumberOfDigits];
    73e4:	e2 2e       	mov	r14, r18
    73e6:	f1 2c       	mov	r15, r1
    73e8:	2d b7       	in	r18, 0x3d	; 61
    73ea:	3e b7       	in	r19, 0x3e	; 62
    73ec:	2e 19       	sub	r18, r14
    73ee:	3f 09       	sbc	r19, r15
    73f0:	0f b6       	in	r0, 0x3f	; 63
    73f2:	f8 94       	cli
    73f4:	3e bf       	out	0x3e, r19	; 62
    73f6:	0f be       	out	0x3f, r0	; 63
    73f8:	2d bf       	out	0x3d, r18	; 61
    73fa:	2f 5f       	subi	r18, 0xFF	; 255
    73fc:	3f 4f       	sbci	r19, 0xFF	; 255
    73fe:	69 01       	movw	r12, r18
	itoa(IntegerToDisplay,StringToDisplay,10);
    7400:	4a e0       	ldi	r20, 0x0A	; 10
    7402:	50 e0       	ldi	r21, 0x00	; 0
    7404:	b9 01       	movw	r22, r18
    7406:	0e 94 3a 3d 	call	0x7a74	; 0x7a74 <itoa>
	for (uint16_t i=0;i<NumberOfDigits;i++)
    740a:	00 e0       	ldi	r16, 0x00	; 0
    740c:	10 e0       	ldi	r17, 0x00	; 0
    740e:	05 c0       	rjmp	.+10     	; 0x741a <LCD_Send_An_Integer_WithLoc+0x5c>
	LCD_Send_A_Character_With_CurrLoc(' ');
    7410:	80 e2       	ldi	r24, 0x20	; 32
    7412:	0e 94 76 39 	call	0x72ec	; 0x72ec <LCD_Send_A_Character_With_CurrLoc>

void LCD_Send_An_Integer_WithLoc(uint8_t y, uint8_t x, uint16_t IntegerToDisplay, uint8_t NumberOfDigits)
{
	uint8_t StringToDisplay[NumberOfDigits];
	itoa(IntegerToDisplay,StringToDisplay,10);
	for (uint16_t i=0;i<NumberOfDigits;i++)
    7416:	0f 5f       	subi	r16, 0xFF	; 255
    7418:	1f 4f       	sbci	r17, 0xFF	; 255
    741a:	0e 15       	cp	r16, r14
    741c:	1f 05       	cpc	r17, r15
    741e:	c0 f3       	brcs	.-16     	; 0x7410 <LCD_Send_An_Integer_WithLoc+0x52>
	LCD_Send_A_Character_With_CurrLoc(' ');
	
	LCD_Send_A_String_WithLoc(y,x,StringToDisplay);
    7420:	a6 01       	movw	r20, r12
    7422:	68 2d       	mov	r22, r8
    7424:	89 2d       	mov	r24, r9
    7426:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <LCD_Send_A_String_WithLoc>
}
    742a:	0f b6       	in	r0, 0x3f	; 63
    742c:	f8 94       	cli
    742e:	be be       	out	0x3e, r11	; 62
    7430:	0f be       	out	0x3f, r0	; 63
    7432:	ad be       	out	0x3d, r10	; 61
    7434:	df 91       	pop	r29
    7436:	cf 91       	pop	r28
    7438:	1f 91       	pop	r17
    743a:	0f 91       	pop	r16
    743c:	ff 90       	pop	r15
    743e:	ef 90       	pop	r14
    7440:	df 90       	pop	r13
    7442:	cf 90       	pop	r12
    7444:	bf 90       	pop	r11
    7446:	af 90       	pop	r10
    7448:	9f 90       	pop	r9
    744a:	8f 90       	pop	r8
    744c:	08 95       	ret

0000744e <main>:
CANMesg_t RecievedMesg ;
uint8_t counter ;
uint16_t  eepromadd ;
int main(void)
{
	DDRD = 0xe0;
    744e:	80 ee       	ldi	r24, 0xE0	; 224
    7450:	81 bb       	out	0x11, r24	; 17
	uint16_t Avr_Word =0; 
	unsigned char *buf = NULL;	
	
	
	
	MCP2515_init();   /* initialize the MCP2515 chip */
    7452:	0e 94 9d 3c 	call	0x793a	; 0x793a <MCP2515_init>
	LCD_Initializaion(); /* initialize LCD */
    7456:	0e 94 a0 39 	call	0x7340	; 0x7340 <LCD_Initializaion>
	
	//uint8_t App [ 512 ]; /* start with app size 4 pages */
	uint8_t sreg;  /* Temp var to hold the status register value */
	uint32_t page_Num = 0; /* here we have 4 pages form 0 -3 */
	uint16_t Avr_Word =0; 
	unsigned char *buf = NULL;	
    745a:	e1 2c       	mov	r14, r1
    745c:	f1 2c       	mov	r15, r1
    /* Replace with your application code */
    while (1) 
    {

		/* first in this example we will we polling mode next example we will we interrupt mode  */
		if (MCP2515_Read_Register(CANINTF) & 0x01) 
    745e:	8c e2       	ldi	r24, 0x2C	; 44
    7460:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <MCP2515_Read_Register>
    7464:	80 ff       	sbrs	r24, 0
    7466:	1c c0       	rjmp	.+56     	; 0x74a0 <main+0x52>
		{
				MCP2515_receiveMesg(&RecievedMesg);
    7468:	89 e8       	ldi	r24, 0x89	; 137
    746a:	90 e0       	ldi	r25, 0x00	; 0
    746c:	0e 94 c9 3c 	call	0x7992	; 0x7992 <MCP2515_receiveMesg>
				eeprom_write_block(RecievedMesg.MesgData ,eepromadd ,8 );
    7470:	60 91 87 00 	lds	r22, 0x0087	; 0x800087 <eepromadd>
    7474:	70 91 88 00 	lds	r23, 0x0088	; 0x800088 <eepromadd+0x1>
    7478:	48 e0       	ldi	r20, 0x08	; 8
    747a:	50 e0       	ldi	r21, 0x00	; 0
    747c:	8e e8       	ldi	r24, 0x8E	; 142
    747e:	90 e0       	ldi	r25, 0x00	; 0
    7480:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <eeprom_write_block>
				eepromadd += 8;
    7484:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <eepromadd>
    7488:	90 91 88 00 	lds	r25, 0x0088	; 0x800088 <eepromadd+0x1>
    748c:	08 96       	adiw	r24, 0x08	; 8
    748e:	90 93 88 00 	sts	0x0088, r25	; 0x800088 <eepromadd+0x1>
    7492:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <eepromadd>
				counter++ ;
    7496:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <counter>
    749a:	8f 5f       	subi	r24, 0xFF	; 255
    749c:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <counter>

		}
		
		/* now we received our message successfully so we need to carry out the boot operation */
		if (counter >= 22)
    74a0:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <counter>
    74a4:	86 31       	cpi	r24, 0x16	; 22
    74a6:	08 f4       	brcc	.+2      	; 0x74aa <main+0x5c>
    74a8:	75 c0       	rjmp	.+234    	; 0x7594 <main+0x146>
		{

		/* Disable interrupts before start nay operation on the flash as explained in the data sheet */
		sreg = SREG;
    74aa:	5f b6       	in	r5, 0x3f	; 63
		cli();
    74ac:	f8 94       	cli
		
		/* flash the code */
		for ( page_Num =0;page_Num <4 ;page_Num++)	 /* iterate on the for pages */
    74ae:	81 2c       	mov	r8, r1
    74b0:	91 2c       	mov	r9, r1
    74b2:	54 01       	movw	r10, r8
    74b4:	51 c0       	rjmp	.+162    	; 0x7558 <main+0x10a>
		{

			eeprom_busy_wait ();
    74b6:	e1 99       	sbic	0x1c, 1	; 28
    74b8:	fe cf       	rjmp	.-4      	; 0x74b6 <main+0x68>
			boot_page_erase_safe (page_Num*SPM_PAGESIZE);
    74ba:	07 b6       	in	r0, 0x37	; 55
    74bc:	00 fc       	sbrc	r0, 0
    74be:	fd cf       	rjmp	.-6      	; 0x74ba <main+0x6c>
    74c0:	e1 99       	sbic	0x1c, 1	; 28
    74c2:	fe cf       	rjmp	.-4      	; 0x74c0 <main+0x72>
    74c4:	34 01       	movw	r6, r8
    74c6:	76 94       	lsr	r7
    74c8:	76 2c       	mov	r7, r6
    74ca:	66 24       	eor	r6, r6
    74cc:	77 94       	ror	r7
    74ce:	67 94       	ror	r6
    74d0:	83 e0       	ldi	r24, 0x03	; 3
    74d2:	f3 01       	movw	r30, r6
    74d4:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    74d8:	e8 95       	spm
			boot_spm_busy_wait ();      /* Wait until the memory is erased */
    74da:	07 b6       	in	r0, 0x37	; 55
    74dc:	00 fc       	sbrc	r0, 0
    74de:	fd cf       	rjmp	.-6      	; 0x74da <main+0x8c>
    74e0:	00 e0       	ldi	r16, 0x00	; 0
    74e2:	10 e0       	ldi	r17, 0x00	; 0
    74e4:	1f c0       	rjmp	.+62     	; 0x7524 <main+0xd6>

			for (int iterator=0; iterator<SPM_PAGESIZE; iterator+=2) /* fill the temp buffer */
			{
				
				Avr_Word = eeprom_read_byte(buf++);
    74e6:	c7 01       	movw	r24, r14
    74e8:	0e 94 7a 3d 	call	0x7af4	; 0x7af4 <eeprom_read_byte>
    74ec:	c8 2f       	mov	r28, r24
    74ee:	d0 e0       	ldi	r29, 0x00	; 0
				Avr_Word |= eeprom_read_byte(buf++) << 8;
    74f0:	c7 01       	movw	r24, r14
    74f2:	01 96       	adiw	r24, 0x01	; 1
    74f4:	f2 e0       	ldi	r31, 0x02	; 2
    74f6:	ef 0e       	add	r14, r31
    74f8:	f1 1c       	adc	r15, r1
    74fa:	0e 94 7a 3d 	call	0x7af4	; 0x7af4 <eeprom_read_byte>
    74fe:	90 e0       	ldi	r25, 0x00	; 0
    7500:	98 2f       	mov	r25, r24
    7502:	88 27       	eor	r24, r24
    7504:	8c 2b       	or	r24, r28
    7506:	9d 2b       	or	r25, r29
				
				boot_page_fill_safe (iterator, Avr_Word); /* write to the temp flash buffer */
    7508:	07 b6       	in	r0, 0x37	; 55
    750a:	00 fc       	sbrc	r0, 0
    750c:	fd cf       	rjmp	.-6      	; 0x7508 <main+0xba>
    750e:	e1 99       	sbic	0x1c, 1	; 28
    7510:	fe cf       	rjmp	.-4      	; 0x750e <main+0xc0>
    7512:	21 e0       	ldi	r18, 0x01	; 1
    7514:	f6 01       	movw	r30, r12
    7516:	0c 01       	movw	r0, r24
    7518:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    751c:	e8 95       	spm
    751e:	11 24       	eor	r1, r1

			eeprom_busy_wait ();
			boot_page_erase_safe (page_Num*SPM_PAGESIZE);
			boot_spm_busy_wait ();      /* Wait until the memory is erased */

			for (int iterator=0; iterator<SPM_PAGESIZE; iterator+=2) /* fill the temp buffer */
    7520:	0e 5f       	subi	r16, 0xFE	; 254
    7522:	1f 4f       	sbci	r17, 0xFF	; 255
    7524:	68 01       	movw	r12, r16
    7526:	00 38       	cpi	r16, 0x80	; 128
    7528:	11 05       	cpc	r17, r1
    752a:	e8 f2       	brcs	.-70     	; 0x74e6 <main+0x98>
				Avr_Word = eeprom_read_byte(buf++);
				Avr_Word |= eeprom_read_byte(buf++) << 8;
				
				boot_page_fill_safe (iterator, Avr_Word); /* write to the temp flash buffer */
			}
			boot_page_write_safe (page_Num*SPM_PAGESIZE);     /* Store temp flash buffer in flash page */
    752c:	07 b6       	in	r0, 0x37	; 55
    752e:	00 fc       	sbrc	r0, 0
    7530:	fd cf       	rjmp	.-6      	; 0x752c <main+0xde>
    7532:	e1 99       	sbic	0x1c, 1	; 28
    7534:	fe cf       	rjmp	.-4      	; 0x7532 <main+0xe4>
    7536:	85 e0       	ldi	r24, 0x05	; 5
    7538:	f3 01       	movw	r30, r6
    753a:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    753e:	e8 95       	spm
			boot_spm_busy_wait();							 /* Wait until write operation is ended */
    7540:	07 b6       	in	r0, 0x37	; 55
    7542:	00 fc       	sbrc	r0, 0
    7544:	fd cf       	rjmp	.-6      	; 0x7540 <main+0xf2>
			boot_rww_enable ();
    7546:	81 e1       	ldi	r24, 0x11	; 17
    7548:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    754c:	e8 95       	spm
		/* Disable interrupts before start nay operation on the flash as explained in the data sheet */
		sreg = SREG;
		cli();
		
		/* flash the code */
		for ( page_Num =0;page_Num <4 ;page_Num++)	 /* iterate on the for pages */
    754e:	ff ef       	ldi	r31, 0xFF	; 255
    7550:	8f 1a       	sub	r8, r31
    7552:	9f 0a       	sbc	r9, r31
    7554:	af 0a       	sbc	r10, r31
    7556:	bf 0a       	sbc	r11, r31
    7558:	24 e0       	ldi	r18, 0x04	; 4
    755a:	82 16       	cp	r8, r18
    755c:	91 04       	cpc	r9, r1
    755e:	a1 04       	cpc	r10, r1
    7560:	b1 04       	cpc	r11, r1
    7562:	08 f4       	brcc	.+2      	; 0x7566 <main+0x118>
    7564:	a8 cf       	rjmp	.-176    	; 0x74b6 <main+0x68>
			boot_rww_enable ();


		}
		/* branch to the application section in the flash */
			LCD_Send_An_Integer_WithLoc(2,10,counter,3);
    7566:	40 91 97 00 	lds	r20, 0x0097	; 0x800097 <counter>
    756a:	50 e0       	ldi	r21, 0x00	; 0
    756c:	23 e0       	ldi	r18, 0x03	; 3
    756e:	6a e0       	ldi	r22, 0x0A	; 10
    7570:	82 e0       	ldi	r24, 0x02	; 2
    7572:	0e 94 df 39 	call	0x73be	; 0x73be <LCD_Send_An_Integer_WithLoc>
			LCD_Send_A_String_WithLoc(1,3,"branching to ");
    7576:	42 e6       	ldi	r20, 0x62	; 98
    7578:	50 e0       	ldi	r21, 0x00	; 0
    757a:	63 e0       	ldi	r22, 0x03	; 3
    757c:	81 e0       	ldi	r24, 0x01	; 1
    757e:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <LCD_Send_A_String_WithLoc>
			LCD_Send_A_String_WithLoc(2,3,"image");
    7582:	40 e7       	ldi	r20, 0x70	; 112
    7584:	50 e0       	ldi	r21, 0x00	; 0
    7586:	63 e0       	ldi	r22, 0x03	; 3
    7588:	82 e0       	ldi	r24, 0x02	; 2
    758a:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <LCD_Send_A_String_WithLoc>
		SREG = sreg;
    758e:	5f be       	out	0x3f, r5	; 63
		asm ( "jmp 0x0000" );			
    7590:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>
			
		}
		
	
		
		LCD_Send_A_Command(LCD_COMMANED_CLEAR_LCD);
    7594:	81 e0       	ldi	r24, 0x01	; 1
    7596:	0e 94 89 39 	call	0x7312	; 0x7312 <LCD_Send_A_Command>
    }
    759a:	61 cf       	rjmp	.-318    	; 0x745e <main+0x10>

0000759c <__vector_1>:
	return 0 ;
}

ISR(INT0_vect)
{
    759c:	1f 92       	push	r1
    759e:	0f 92       	push	r0
    75a0:	0f b6       	in	r0, 0x3f	; 63
    75a2:	0f 92       	push	r0
    75a4:	11 24       	eor	r1, r1
    75a6:	2f 93       	push	r18
    75a8:	3f 93       	push	r19
    75aa:	4f 93       	push	r20
    75ac:	5f 93       	push	r21
    75ae:	6f 93       	push	r22
    75b0:	7f 93       	push	r23
    75b2:	8f 93       	push	r24
    75b4:	9f 93       	push	r25
    75b6:	af 93       	push	r26
    75b8:	bf 93       	push	r27
    75ba:	ef 93       	push	r30
    75bc:	ff 93       	push	r31

	counter++;
    75be:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <counter>
    75c2:	8f 5f       	subi	r24, 0xFF	; 255
    75c4:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <counter>

	MCP2515_receiveMesg(&RecievedMesg);
    75c8:	89 e8       	ldi	r24, 0x89	; 137
    75ca:	90 e0       	ldi	r25, 0x00	; 0
    75cc:	0e 94 c9 3c 	call	0x7992	; 0x7992 <MCP2515_receiveMesg>
	
	PORTD = 0x80;
    75d0:	80 e8       	ldi	r24, 0x80	; 128
    75d2:	82 bb       	out	0x12, r24	; 18

    75d4:	ff 91       	pop	r31
    75d6:	ef 91       	pop	r30
    75d8:	bf 91       	pop	r27
    75da:	af 91       	pop	r26
    75dc:	9f 91       	pop	r25
    75de:	8f 91       	pop	r24
    75e0:	7f 91       	pop	r23
    75e2:	6f 91       	pop	r22
    75e4:	5f 91       	pop	r21
    75e6:	4f 91       	pop	r20
    75e8:	3f 91       	pop	r19
    75ea:	2f 91       	pop	r18
    75ec:	0f 90       	pop	r0
    75ee:	0f be       	out	0x3f, r0	; 63
    75f0:	0f 90       	pop	r0
    75f2:	1f 90       	pop	r1
    75f4:	18 95       	reti

000075f6 <MCP2515_Read_Register>:
	dataTx[0] = 0x81+TXnum;
	HAL_SPI_Transmit(&MCP2515_SPIHandler,dataTx,1);
	
	
	
}/* END_FUN MCP2515_SendCANmsg() */
    75f6:	cf 93       	push	r28
    75f8:	df 93       	push	r29
    75fa:	00 d0       	rcall	.+0      	; 0x75fc <MCP2515_Read_Register+0x6>
    75fc:	1f 92       	push	r1
    75fe:	cd b7       	in	r28, 0x3d	; 61
    7600:	de b7       	in	r29, 0x3e	; 62
    7602:	93 e0       	ldi	r25, 0x03	; 3
    7604:	99 83       	std	Y+1, r25	; 0x01
    7606:	8a 83       	std	Y+2, r24	; 0x02
    7608:	1b 82       	std	Y+3, r1	; 0x03
    760a:	23 e0       	ldi	r18, 0x03	; 3
    760c:	30 e0       	ldi	r19, 0x00	; 0
    760e:	ae 01       	movw	r20, r28
    7610:	4f 5f       	subi	r20, 0xFF	; 255
    7612:	5f 4f       	sbci	r21, 0xFF	; 255
    7614:	ba 01       	movw	r22, r20
    7616:	89 e7       	ldi	r24, 0x79	; 121
    7618:	90 e0       	ldi	r25, 0x00	; 0
    761a:	0e 94 0f 39 	call	0x721e	; 0x721e <HAL_SPI_TransmitRecive>
    761e:	8b 81       	ldd	r24, Y+3	; 0x03
    7620:	0f 90       	pop	r0
    7622:	0f 90       	pop	r0
    7624:	0f 90       	pop	r0
    7626:	df 91       	pop	r29
    7628:	cf 91       	pop	r28
    762a:	08 95       	ret

0000762c <MCP2515_Write_Register>:
    762c:	cf 93       	push	r28
    762e:	df 93       	push	r29
    7630:	00 d0       	rcall	.+0      	; 0x7632 <MCP2515_Write_Register+0x6>
    7632:	1f 92       	push	r1
    7634:	cd b7       	in	r28, 0x3d	; 61
    7636:	de b7       	in	r29, 0x3e	; 62
    7638:	92 e0       	ldi	r25, 0x02	; 2
    763a:	99 83       	std	Y+1, r25	; 0x01
    763c:	8a 83       	std	Y+2, r24	; 0x02
    763e:	6b 83       	std	Y+3, r22	; 0x03
    7640:	43 e0       	ldi	r20, 0x03	; 3
    7642:	50 e0       	ldi	r21, 0x00	; 0
    7644:	be 01       	movw	r22, r28
    7646:	6f 5f       	subi	r22, 0xFF	; 255
    7648:	7f 4f       	sbci	r23, 0xFF	; 255
    764a:	89 e7       	ldi	r24, 0x79	; 121
    764c:	90 e0       	ldi	r25, 0x00	; 0
    764e:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <HAL_SPI_Transmit>
    7652:	0f 90       	pop	r0
    7654:	0f 90       	pop	r0
    7656:	0f 90       	pop	r0
    7658:	df 91       	pop	r29
    765a:	cf 91       	pop	r28
    765c:	08 95       	ret

0000765e <MCP2515_Rest>:
    765e:	cf 93       	push	r28
    7660:	df 93       	push	r29
    7662:	1f 92       	push	r1
    7664:	cd b7       	in	r28, 0x3d	; 61
    7666:	de b7       	in	r29, 0x3e	; 62
    7668:	80 ec       	ldi	r24, 0xC0	; 192
    766a:	89 83       	std	Y+1, r24	; 0x01
    766c:	41 e0       	ldi	r20, 0x01	; 1
    766e:	50 e0       	ldi	r21, 0x00	; 0
    7670:	be 01       	movw	r22, r28
    7672:	6f 5f       	subi	r22, 0xFF	; 255
    7674:	7f 4f       	sbci	r23, 0xFF	; 255
    7676:	89 e7       	ldi	r24, 0x79	; 121
    7678:	90 e0       	ldi	r25, 0x00	; 0
    767a:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <HAL_SPI_Transmit>
    767e:	2f ef       	ldi	r18, 0xFF	; 255
    7680:	89 ef       	ldi	r24, 0xF9	; 249
    7682:	90 e0       	ldi	r25, 0x00	; 0
    7684:	21 50       	subi	r18, 0x01	; 1
    7686:	80 40       	sbci	r24, 0x00	; 0
    7688:	90 40       	sbci	r25, 0x00	; 0
    768a:	e1 f7       	brne	.-8      	; 0x7684 <MCP2515_Rest+0x26>
    768c:	00 c0       	rjmp	.+0      	; 0x768e <MCP2515_Rest+0x30>
    768e:	00 00       	nop
    7690:	0f 90       	pop	r0
    7692:	df 91       	pop	r29
    7694:	cf 91       	pop	r28
    7696:	08 95       	ret

00007698 <MCP2515_SetBitTiming>:
    7698:	cf 93       	push	r28
    769a:	df 93       	push	r29
    769c:	d6 2f       	mov	r29, r22
    769e:	c4 2f       	mov	r28, r20
    76a0:	68 2f       	mov	r22, r24
    76a2:	8a e2       	ldi	r24, 0x2A	; 42
    76a4:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    76a8:	6d 2f       	mov	r22, r29
    76aa:	89 e2       	ldi	r24, 0x29	; 41
    76ac:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    76b0:	6c 2f       	mov	r22, r28
    76b2:	88 e2       	ldi	r24, 0x28	; 40
    76b4:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    76b8:	df 91       	pop	r29
    76ba:	cf 91       	pop	r28
    76bc:	08 95       	ret

000076be <MCP2515_Set_OperMode>:
    76be:	cf 93       	push	r28
    76c0:	df 93       	push	r29
    76c2:	00 d0       	rcall	.+0      	; 0x76c4 <MCP2515_Set_OperMode+0x6>
    76c4:	1f 92       	push	r1
    76c6:	cd b7       	in	r28, 0x3d	; 61
    76c8:	de b7       	in	r29, 0x3e	; 62
    76ca:	92 e0       	ldi	r25, 0x02	; 2
    76cc:	99 83       	std	Y+1, r25	; 0x01
    76ce:	9f e0       	ldi	r25, 0x0F	; 15
    76d0:	9a 83       	std	Y+2, r25	; 0x02
    76d2:	8b 83       	std	Y+3, r24	; 0x03
    76d4:	43 e0       	ldi	r20, 0x03	; 3
    76d6:	50 e0       	ldi	r21, 0x00	; 0
    76d8:	be 01       	movw	r22, r28
    76da:	6f 5f       	subi	r22, 0xFF	; 255
    76dc:	7f 4f       	sbci	r23, 0xFF	; 255
    76de:	89 e7       	ldi	r24, 0x79	; 121
    76e0:	90 e0       	ldi	r25, 0x00	; 0
    76e2:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <HAL_SPI_Transmit>
    76e6:	0f 90       	pop	r0
    76e8:	0f 90       	pop	r0
    76ea:	0f 90       	pop	r0
    76ec:	df 91       	pop	r29
    76ee:	cf 91       	pop	r28
    76f0:	08 95       	ret

000076f2 <MCP2515_SetMask>:
    76f2:	cf 92       	push	r12
    76f4:	df 92       	push	r13
    76f6:	ef 92       	push	r14
    76f8:	ff 92       	push	r15
    76fa:	cf 93       	push	r28
    76fc:	c8 2f       	mov	r28, r24
    76fe:	6a 01       	movw	r12, r20
    7700:	7b 01       	movw	r14, r22
    7702:	22 23       	and	r18, r18
    7704:	09 f4       	brne	.+2      	; 0x7708 <MCP2515_SetMask+0x16>
    7706:	4a c0       	rjmp	.+148    	; 0x779c <MCP2515_SetMask+0xaa>
    7708:	cb 01       	movw	r24, r22
    770a:	ba 01       	movw	r22, r20
    770c:	68 94       	set
    770e:	12 f8       	bld	r1, 2
    7710:	96 95       	lsr	r25
    7712:	87 95       	ror	r24
    7714:	77 95       	ror	r23
    7716:	67 95       	ror	r22
    7718:	16 94       	lsr	r1
    771a:	d1 f7       	brne	.-12     	; 0x7710 <MCP2515_SetMask+0x1e>
    771c:	2c 2f       	mov	r18, r28
    771e:	30 e0       	ldi	r19, 0x00	; 0
    7720:	28 5f       	subi	r18, 0xF8	; 248
    7722:	3f 4f       	sbci	r19, 0xFF	; 255
    7724:	82 2f       	mov	r24, r18
    7726:	88 0f       	add	r24, r24
    7728:	88 0f       	add	r24, r24
    772a:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    772e:	d7 01       	movw	r26, r14
    7730:	c6 01       	movw	r24, r12
    7732:	07 2e       	mov	r0, r23
    7734:	7b e1       	ldi	r23, 0x1B	; 27
    7736:	b6 95       	lsr	r27
    7738:	a7 95       	ror	r26
    773a:	97 95       	ror	r25
    773c:	87 95       	ror	r24
    773e:	7a 95       	dec	r23
    7740:	d1 f7       	brne	.-12     	; 0x7736 <MCP2515_SetMask+0x44>
    7742:	70 2d       	mov	r23, r0
    7744:	cc 0f       	add	r28, r28
    7746:	cc 0f       	add	r28, r28
    7748:	6c 2d       	mov	r22, r12
    774a:	62 95       	swap	r22
    774c:	66 0f       	add	r22, r22
    774e:	60 7e       	andi	r22, 0xE0	; 224
    7750:	86 2b       	or	r24, r22
    7752:	68 2f       	mov	r22, r24
    7754:	68 60       	ori	r22, 0x08	; 8
    7756:	81 e2       	ldi	r24, 0x21	; 33
    7758:	8c 0f       	add	r24, r28
    775a:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    775e:	c7 01       	movw	r24, r14
    7760:	b6 01       	movw	r22, r12
    7762:	05 2e       	mov	r0, r21
    7764:	5b e0       	ldi	r21, 0x0B	; 11
    7766:	96 95       	lsr	r25
    7768:	87 95       	ror	r24
    776a:	77 95       	ror	r23
    776c:	67 95       	ror	r22
    776e:	5a 95       	dec	r21
    7770:	d1 f7       	brne	.-12     	; 0x7766 <MCP2515_SetMask+0x74>
    7772:	50 2d       	mov	r21, r0
    7774:	83 e2       	ldi	r24, 0x23	; 35
    7776:	8c 0f       	add	r24, r28
    7778:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    777c:	c7 01       	movw	r24, r14
    777e:	b6 01       	movw	r22, r12
    7780:	05 2e       	mov	r0, r21
    7782:	53 e1       	ldi	r21, 0x13	; 19
    7784:	96 95       	lsr	r25
    7786:	87 95       	ror	r24
    7788:	77 95       	ror	r23
    778a:	67 95       	ror	r22
    778c:	5a 95       	dec	r21
    778e:	d1 f7       	brne	.-12     	; 0x7784 <MCP2515_SetMask+0x92>
    7790:	50 2d       	mov	r21, r0
    7792:	82 e2       	ldi	r24, 0x22	; 34
    7794:	8c 0f       	add	r24, r28
    7796:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    779a:	1d c0       	rjmp	.+58     	; 0x77d6 <MCP2515_SetMask+0xe4>
    779c:	cb 01       	movw	r24, r22
    779e:	ba 01       	movw	r22, r20
    77a0:	68 94       	set
    77a2:	12 f8       	bld	r1, 2
    77a4:	96 95       	lsr	r25
    77a6:	87 95       	ror	r24
    77a8:	77 95       	ror	r23
    77aa:	67 95       	ror	r22
    77ac:	16 94       	lsr	r1
    77ae:	d1 f7       	brne	.-12     	; 0x77a4 <MCP2515_SetMask+0xb2>
    77b0:	2c 2f       	mov	r18, r28
    77b2:	30 e0       	ldi	r19, 0x00	; 0
    77b4:	28 5f       	subi	r18, 0xF8	; 248
    77b6:	3f 4f       	sbci	r19, 0xFF	; 255
    77b8:	82 2f       	mov	r24, r18
    77ba:	88 0f       	add	r24, r24
    77bc:	88 0f       	add	r24, r24
    77be:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    77c2:	6c 2d       	mov	r22, r12
    77c4:	62 95       	swap	r22
    77c6:	66 0f       	add	r22, r22
    77c8:	60 7e       	andi	r22, 0xE0	; 224
    77ca:	8c 2f       	mov	r24, r28
    77cc:	88 0f       	add	r24, r24
    77ce:	88 0f       	add	r24, r24
    77d0:	8f 5d       	subi	r24, 0xDF	; 223
    77d2:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    77d6:	cf 91       	pop	r28
    77d8:	ff 90       	pop	r15
    77da:	ef 90       	pop	r14
    77dc:	df 90       	pop	r13
    77de:	cf 90       	pop	r12
    77e0:	08 95       	ret

000077e2 <MCP2515_SetFilter>:
    77e2:	cf 92       	push	r12
    77e4:	df 92       	push	r13
    77e6:	ef 92       	push	r14
    77e8:	ff 92       	push	r15
    77ea:	cf 93       	push	r28
    77ec:	df 93       	push	r29
    77ee:	c8 2f       	mov	r28, r24
    77f0:	6a 01       	movw	r12, r20
    77f2:	7b 01       	movw	r14, r22
    77f4:	22 23       	and	r18, r18
    77f6:	09 f4       	brne	.+2      	; 0x77fa <MCP2515_SetFilter+0x18>
    77f8:	5c c0       	rjmp	.+184    	; 0x78b2 <MCP2515_SetFilter+0xd0>
    77fa:	cb 01       	movw	r24, r22
    77fc:	ba 01       	movw	r22, r20
    77fe:	68 94       	set
    7800:	12 f8       	bld	r1, 2
    7802:	96 95       	lsr	r25
    7804:	87 95       	ror	r24
    7806:	77 95       	ror	r23
    7808:	67 95       	ror	r22
    780a:	16 94       	lsr	r1
    780c:	d1 f7       	brne	.-12     	; 0x7802 <MCP2515_SetFilter+0x20>
    780e:	dc 2f       	mov	r29, r28
    7810:	dd 0f       	add	r29, r29
    7812:	dd 0f       	add	r29, r29
    7814:	c3 30       	cpi	r28, 0x03	; 3
    7816:	10 f0       	brcs	.+4      	; 0x781c <MCP2515_SetFilter+0x3a>
    7818:	24 e0       	ldi	r18, 0x04	; 4
    781a:	01 c0       	rjmp	.+2      	; 0x781e <MCP2515_SetFilter+0x3c>
    781c:	20 e0       	ldi	r18, 0x00	; 0
    781e:	82 2f       	mov	r24, r18
    7820:	8d 0f       	add	r24, r29
    7822:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    7826:	8c 2d       	mov	r24, r12
    7828:	82 95       	swap	r24
    782a:	88 0f       	add	r24, r24
    782c:	80 7e       	andi	r24, 0xE0	; 224
    782e:	b7 01       	movw	r22, r14
    7830:	a6 01       	movw	r20, r12
    7832:	03 2e       	mov	r0, r19
    7834:	3b e1       	ldi	r19, 0x1B	; 27
    7836:	76 95       	lsr	r23
    7838:	67 95       	ror	r22
    783a:	57 95       	ror	r21
    783c:	47 95       	ror	r20
    783e:	3a 95       	dec	r19
    7840:	d1 f7       	brne	.-12     	; 0x7836 <MCP2515_SetFilter+0x54>
    7842:	30 2d       	mov	r19, r0
    7844:	48 2b       	or	r20, r24
    7846:	64 2f       	mov	r22, r20
    7848:	68 60       	ori	r22, 0x08	; 8
    784a:	c3 30       	cpi	r28, 0x03	; 3
    784c:	10 f0       	brcs	.+4      	; 0x7852 <MCP2515_SetFilter+0x70>
    784e:	84 e0       	ldi	r24, 0x04	; 4
    7850:	01 c0       	rjmp	.+2      	; 0x7854 <MCP2515_SetFilter+0x72>
    7852:	80 e0       	ldi	r24, 0x00	; 0
    7854:	8d 0f       	add	r24, r29
    7856:	8f 5f       	subi	r24, 0xFF	; 255
    7858:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    785c:	c7 01       	movw	r24, r14
    785e:	b6 01       	movw	r22, r12
    7860:	05 2e       	mov	r0, r21
    7862:	5b e0       	ldi	r21, 0x0B	; 11
    7864:	96 95       	lsr	r25
    7866:	87 95       	ror	r24
    7868:	77 95       	ror	r23
    786a:	67 95       	ror	r22
    786c:	5a 95       	dec	r21
    786e:	d1 f7       	brne	.-12     	; 0x7864 <MCP2515_SetFilter+0x82>
    7870:	50 2d       	mov	r21, r0
    7872:	c3 30       	cpi	r28, 0x03	; 3
    7874:	10 f0       	brcs	.+4      	; 0x787a <MCP2515_SetFilter+0x98>
    7876:	24 e0       	ldi	r18, 0x04	; 4
    7878:	01 c0       	rjmp	.+2      	; 0x787c <MCP2515_SetFilter+0x9a>
    787a:	20 e0       	ldi	r18, 0x00	; 0
    787c:	2d 0f       	add	r18, r29
    787e:	83 e0       	ldi	r24, 0x03	; 3
    7880:	82 0f       	add	r24, r18
    7882:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    7886:	c7 01       	movw	r24, r14
    7888:	b6 01       	movw	r22, r12
    788a:	05 2e       	mov	r0, r21
    788c:	53 e1       	ldi	r21, 0x13	; 19
    788e:	96 95       	lsr	r25
    7890:	87 95       	ror	r24
    7892:	77 95       	ror	r23
    7894:	67 95       	ror	r22
    7896:	5a 95       	dec	r21
    7898:	d1 f7       	brne	.-12     	; 0x788e <MCP2515_SetFilter+0xac>
    789a:	50 2d       	mov	r21, r0
    789c:	c3 30       	cpi	r28, 0x03	; 3
    789e:	10 f0       	brcs	.+4      	; 0x78a4 <MCP2515_SetFilter+0xc2>
    78a0:	24 e0       	ldi	r18, 0x04	; 4
    78a2:	01 c0       	rjmp	.+2      	; 0x78a6 <MCP2515_SetFilter+0xc4>
    78a4:	20 e0       	ldi	r18, 0x00	; 0
    78a6:	2d 0f       	add	r18, r29
    78a8:	82 e0       	ldi	r24, 0x02	; 2
    78aa:	82 0f       	add	r24, r18
    78ac:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    78b0:	23 c0       	rjmp	.+70     	; 0x78f8 <MCP2515_SetFilter+0x116>
    78b2:	cb 01       	movw	r24, r22
    78b4:	ba 01       	movw	r22, r20
    78b6:	68 94       	set
    78b8:	12 f8       	bld	r1, 2
    78ba:	96 95       	lsr	r25
    78bc:	87 95       	ror	r24
    78be:	77 95       	ror	r23
    78c0:	67 95       	ror	r22
    78c2:	16 94       	lsr	r1
    78c4:	d1 f7       	brne	.-12     	; 0x78ba <MCP2515_SetFilter+0xd8>
    78c6:	dc 2f       	mov	r29, r28
    78c8:	dd 0f       	add	r29, r29
    78ca:	dd 0f       	add	r29, r29
    78cc:	c3 30       	cpi	r28, 0x03	; 3
    78ce:	10 f0       	brcs	.+4      	; 0x78d4 <MCP2515_SetFilter+0xf2>
    78d0:	24 e0       	ldi	r18, 0x04	; 4
    78d2:	01 c0       	rjmp	.+2      	; 0x78d6 <MCP2515_SetFilter+0xf4>
    78d4:	20 e0       	ldi	r18, 0x00	; 0
    78d6:	82 2f       	mov	r24, r18
    78d8:	8d 0f       	add	r24, r29
    78da:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    78de:	6c 2d       	mov	r22, r12
    78e0:	62 95       	swap	r22
    78e2:	66 0f       	add	r22, r22
    78e4:	60 7e       	andi	r22, 0xE0	; 224
    78e6:	c3 30       	cpi	r28, 0x03	; 3
    78e8:	10 f0       	brcs	.+4      	; 0x78ee <MCP2515_SetFilter+0x10c>
    78ea:	84 e0       	ldi	r24, 0x04	; 4
    78ec:	01 c0       	rjmp	.+2      	; 0x78f0 <MCP2515_SetFilter+0x10e>
    78ee:	80 e0       	ldi	r24, 0x00	; 0
    78f0:	8d 0f       	add	r24, r29
    78f2:	8f 5f       	subi	r24, 0xFF	; 255
    78f4:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    78f8:	df 91       	pop	r29
    78fa:	cf 91       	pop	r28
    78fc:	ff 90       	pop	r15
    78fe:	ef 90       	pop	r14
    7900:	df 90       	pop	r13
    7902:	cf 90       	pop	r12
    7904:	08 95       	ret

00007906 <MCP2515_Enable_Interrupt>:
    7906:	cf 93       	push	r28
    7908:	df 93       	push	r29
    790a:	00 d0       	rcall	.+0      	; 0x790c <MCP2515_Enable_Interrupt+0x6>
    790c:	1f 92       	push	r1
    790e:	cd b7       	in	r28, 0x3d	; 61
    7910:	de b7       	in	r29, 0x3e	; 62
    7912:	92 e0       	ldi	r25, 0x02	; 2
    7914:	99 83       	std	Y+1, r25	; 0x01
    7916:	9b e2       	ldi	r25, 0x2B	; 43
    7918:	9a 83       	std	Y+2, r25	; 0x02
    791a:	8b 83       	std	Y+3, r24	; 0x03
    791c:	43 e0       	ldi	r20, 0x03	; 3
    791e:	50 e0       	ldi	r21, 0x00	; 0
    7920:	be 01       	movw	r22, r28
    7922:	6f 5f       	subi	r22, 0xFF	; 255
    7924:	7f 4f       	sbci	r23, 0xFF	; 255
    7926:	89 e7       	ldi	r24, 0x79	; 121
    7928:	90 e0       	ldi	r25, 0x00	; 0
    792a:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <HAL_SPI_Transmit>
    792e:	0f 90       	pop	r0
    7930:	0f 90       	pop	r0
    7932:	0f 90       	pop	r0
    7934:	df 91       	pop	r29
    7936:	cf 91       	pop	r28
    7938:	08 95       	ret

0000793a <MCP2515_init>:
    793a:	e9 e7       	ldi	r30, 0x79	; 121
    793c:	f0 e0       	ldi	r31, 0x00	; 0
    793e:	80 e1       	ldi	r24, 0x10	; 16
    7940:	80 83       	st	Z, r24
    7942:	84 e1       	ldi	r24, 0x14	; 20
    7944:	83 83       	std	Z+3, r24	; 0x03
    7946:	cf 01       	movw	r24, r30
    7948:	0e 94 7e 38 	call	0x70fc	; 0x70fc <HAL_SPI_Init>
    794c:	0e 94 2f 3b 	call	0x765e	; 0x765e <MCP2515_Rest>
    7950:	83 e0       	ldi	r24, 0x03	; 3
    7952:	0e 94 83 3c 	call	0x7906	; 0x7906 <MCP2515_Enable_Interrupt>
    7956:	80 e8       	ldi	r24, 0x80	; 128
    7958:	0e 94 5f 3b 	call	0x76be	; 0x76be <MCP2515_Set_OperMode>
    795c:	47 e8       	ldi	r20, 0x87	; 135
    795e:	6a ef       	ldi	r22, 0xFA	; 250
    7960:	83 e0       	ldi	r24, 0x03	; 3
    7962:	0e 94 4c 3b 	call	0x7698	; 0x7698 <MCP2515_SetBitTiming>
    7966:	21 e0       	ldi	r18, 0x01	; 1
    7968:	40 e0       	ldi	r20, 0x00	; 0
    796a:	50 e0       	ldi	r21, 0x00	; 0
    796c:	ba 01       	movw	r22, r20
    796e:	80 e0       	ldi	r24, 0x00	; 0
    7970:	0e 94 f1 3b 	call	0x77e2	; 0x77e2 <MCP2515_SetFilter>
    7974:	21 e0       	ldi	r18, 0x01	; 1
    7976:	40 e0       	ldi	r20, 0x00	; 0
    7978:	50 e0       	ldi	r21, 0x00	; 0
    797a:	ba 01       	movw	r22, r20
    797c:	80 e0       	ldi	r24, 0x00	; 0
    797e:	0e 94 79 3b 	call	0x76f2	; 0x76f2 <MCP2515_SetMask>
    7982:	67 e0       	ldi	r22, 0x07	; 7
    7984:	8d e0       	ldi	r24, 0x0D	; 13
    7986:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
    798a:	80 e0       	ldi	r24, 0x00	; 0
    798c:	0e 94 5f 3b 	call	0x76be	; 0x76be <MCP2515_Set_OperMode>
    7990:	08 95       	ret

00007992 <MCP2515_receiveMesg>:
 * param : RecievedMesg pointer to struct that will hold all receive message information 
 * return : bool if false means their is no pending message to read   
 */

PUBLIC bool MCP2515_receiveMesg(CANMesg_t * RecievedMesg)
{
    7992:	ef 92       	push	r14
    7994:	ff 92       	push	r15
    7996:	0f 93       	push	r16
    7998:	1f 93       	push	r17
    799a:	cf 93       	push	r28
    799c:	df 93       	push	r29
    799e:	7c 01       	movw	r14, r24
	uint8_t CANReaddata =0,MAilBoxNum =0,iterator=0 ;
	CANReaddata = MCP2515_Read_Register(CANINTF);
    79a0:	8c e2       	ldi	r24, 0x2C	; 44
    79a2:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <MCP2515_Read_Register>
	if((CANReaddata & 0x01))
    79a6:	80 fd       	sbrc	r24, 0
    79a8:	04 c0       	rjmp	.+8      	; 0x79b2 <MCP2515_receiveMesg+0x20>
	{
		MAilBoxNum = 0 ;
	}
	else if((CANReaddata & 0x02)) /* means there is message is in Mailbox1 */
    79aa:	81 ff       	sbrs	r24, 1
    79ac:	5b c0       	rjmp	.+182    	; 0x7a64 <MCP2515_receiveMesg+0xd2>
	{
		MAilBoxNum = 1 ;
    79ae:	d1 e0       	ldi	r29, 0x01	; 1
    79b0:	01 c0       	rjmp	.+2      	; 0x79b4 <MCP2515_receiveMesg+0x22>
{
	uint8_t CANReaddata =0,MAilBoxNum =0,iterator=0 ;
	CANReaddata = MCP2515_Read_Register(CANINTF);
	if((CANReaddata & 0x01))
	{
		MAilBoxNum = 0 ;
    79b2:	d0 e0       	ldi	r29, 0x00	; 0
	}
	else{
		return 0 ;
	}

	CANReaddata = MCP2515_Read_Register(CANSTAT);
    79b4:	8e e0       	ldi	r24, 0x0E	; 14
    79b6:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <MCP2515_Read_Register>
	RecievedMesg->CANControl.RTR_Field = (CANReaddata & 0x40)>>6 ;
    79ba:	80 74       	andi	r24, 0x40	; 64
    79bc:	90 e0       	ldi	r25, 0x00	; 0
    79be:	08 2e       	mov	r0, r24
    79c0:	89 2f       	mov	r24, r25
    79c2:	00 0c       	add	r0, r0
    79c4:	88 1f       	adc	r24, r24
    79c6:	99 0b       	sbc	r25, r25
    79c8:	00 0c       	add	r0, r0
    79ca:	88 1f       	adc	r24, r24
    79cc:	99 1f       	adc	r25, r25
    79ce:	f7 01       	movw	r30, r14
    79d0:	94 81       	ldd	r25, Z+4	; 0x04
    79d2:	80 fb       	bst	r24, 0
    79d4:	95 f9       	bld	r25, 5
    79d6:	94 83       	std	Z+4, r25	; 0x04
	CANReaddata = MCP2515_Read_Register(RXBnSIDL(MAilBoxNum));
    79d8:	d2 95       	swap	r29
    79da:	d0 7f       	andi	r29, 0xF0	; 240
    79dc:	82 e6       	ldi	r24, 0x62	; 98
    79de:	8d 0f       	add	r24, r29
    79e0:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <MCP2515_Read_Register>
    79e4:	c8 2f       	mov	r28, r24
	RecievedMesg->CANControl.EXT_Field = (CANReaddata & 0x08 )>>3 ;
    79e6:	88 70       	andi	r24, 0x08	; 8
    79e8:	90 e0       	ldi	r25, 0x00	; 0
    79ea:	95 95       	asr	r25
    79ec:	87 95       	ror	r24
    79ee:	95 95       	asr	r25
    79f0:	87 95       	ror	r24
    79f2:	95 95       	asr	r25
    79f4:	87 95       	ror	r24
    79f6:	f7 01       	movw	r30, r14
    79f8:	94 81       	ldd	r25, Z+4	; 0x04
    79fa:	80 fb       	bst	r24, 0
    79fc:	94 f9       	bld	r25, 4
    79fe:	94 83       	std	Z+4, r25	; 0x04
	RecievedMesg->ID  = MCP2515_Read_Register(RXBnSIDH(MAilBoxNum));
    7a00:	81 e6       	ldi	r24, 0x61	; 97
    7a02:	8d 0f       	add	r24, r29
    7a04:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <MCP2515_Read_Register>
    7a08:	90 e0       	ldi	r25, 0x00	; 0
    7a0a:	a0 e0       	ldi	r26, 0x00	; 0
    7a0c:	b0 e0       	ldi	r27, 0x00	; 0
	RecievedMesg->ID  = (((uint32_t)RecievedMesg->ID<<3)|(CANReaddata>>5));
    7a0e:	88 0f       	add	r24, r24
    7a10:	99 1f       	adc	r25, r25
    7a12:	aa 1f       	adc	r26, r26
    7a14:	bb 1f       	adc	r27, r27
    7a16:	88 0f       	add	r24, r24
    7a18:	99 1f       	adc	r25, r25
    7a1a:	aa 1f       	adc	r26, r26
    7a1c:	bb 1f       	adc	r27, r27
    7a1e:	88 0f       	add	r24, r24
    7a20:	99 1f       	adc	r25, r25
    7a22:	aa 1f       	adc	r26, r26
    7a24:	bb 1f       	adc	r27, r27
    7a26:	c2 95       	swap	r28
    7a28:	c6 95       	lsr	r28
    7a2a:	c7 70       	andi	r28, 0x07	; 7
    7a2c:	8c 2b       	or	r24, r28
    7a2e:	f7 01       	movw	r30, r14
    7a30:	80 83       	st	Z, r24
    7a32:	91 83       	std	Z+1, r25	; 0x01
    7a34:	a2 83       	std	Z+2, r26	; 0x02
    7a36:	b3 83       	std	Z+3, r27	; 0x03
 * return : bool if false means their is no pending message to read   
 */

PUBLIC bool MCP2515_receiveMesg(CANMesg_t * RecievedMesg)
{
	uint8_t CANReaddata =0,MAilBoxNum =0,iterator=0 ;
    7a38:	c0 e0       	ldi	r28, 0x00	; 0
	RecievedMesg->CANControl.EXT_Field = (CANReaddata & 0x08 )>>3 ;
	RecievedMesg->ID  = MCP2515_Read_Register(RXBnSIDH(MAilBoxNum));
	RecievedMesg->ID  = (((uint32_t)RecievedMesg->ID<<3)|(CANReaddata>>5));
	
	
	while(iterator != 8)
    7a3a:	0c c0       	rjmp	.+24     	; 0x7a54 <MCP2515_receiveMesg+0xc2>
	{
		RecievedMesg->MesgData[iterator] = MCP2515_Read_Register(RXBnDm(MAilBoxNum,iterator));
    7a3c:	0c 2f       	mov	r16, r28
    7a3e:	10 e0       	ldi	r17, 0x00	; 0
    7a40:	8c 2f       	mov	r24, r28
    7a42:	8d 0f       	add	r24, r29
    7a44:	8a 59       	subi	r24, 0x9A	; 154
    7a46:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <MCP2515_Read_Register>
    7a4a:	f7 01       	movw	r30, r14
    7a4c:	e0 0f       	add	r30, r16
    7a4e:	f1 1f       	adc	r31, r17
    7a50:	85 83       	std	Z+5, r24	; 0x05
		iterator++;
    7a52:	cf 5f       	subi	r28, 0xFF	; 255
	RecievedMesg->CANControl.EXT_Field = (CANReaddata & 0x08 )>>3 ;
	RecievedMesg->ID  = MCP2515_Read_Register(RXBnSIDH(MAilBoxNum));
	RecievedMesg->ID  = (((uint32_t)RecievedMesg->ID<<3)|(CANReaddata>>5));
	
	
	while(iterator != 8)
    7a54:	c8 30       	cpi	r28, 0x08	; 8
    7a56:	91 f7       	brne	.-28     	; 0x7a3c <MCP2515_receiveMesg+0xaa>
	{
		RecievedMesg->MesgData[iterator] = MCP2515_Read_Register(RXBnDm(MAilBoxNum,iterator));
		iterator++;
	}

	MCP2515_Write_Register(CANINTF , 0x00 ); /* FIRST CLESR FLAG */
    7a58:	60 e0       	ldi	r22, 0x00	; 0
    7a5a:	8c e2       	ldi	r24, 0x2C	; 44
    7a5c:	0e 94 16 3b 	call	0x762c	; 0x762c <MCP2515_Write_Register>
	return true ;
    7a60:	81 e0       	ldi	r24, 0x01	; 1
    7a62:	01 c0       	rjmp	.+2      	; 0x7a66 <MCP2515_receiveMesg+0xd4>
	else if((CANReaddata & 0x02)) /* means there is message is in Mailbox1 */
	{
		MAilBoxNum = 1 ;
	}
	else{
		return 0 ;
    7a64:	80 e0       	ldi	r24, 0x00	; 0
		iterator++;
	}

	MCP2515_Write_Register(CANINTF , 0x00 ); /* FIRST CLESR FLAG */
	return true ;
    7a66:	df 91       	pop	r29
    7a68:	cf 91       	pop	r28
    7a6a:	1f 91       	pop	r17
    7a6c:	0f 91       	pop	r16
    7a6e:	ff 90       	pop	r15
    7a70:	ef 90       	pop	r14
    7a72:	08 95       	ret

00007a74 <itoa>:
    7a74:	45 32       	cpi	r20, 0x25	; 37
    7a76:	51 05       	cpc	r21, r1
    7a78:	20 f4       	brcc	.+8      	; 0x7a82 <itoa+0xe>
    7a7a:	42 30       	cpi	r20, 0x02	; 2
    7a7c:	10 f0       	brcs	.+4      	; 0x7a82 <itoa+0xe>
    7a7e:	0c 94 45 3d 	jmp	0x7a8a	; 0x7a8a <__itoa_ncheck>
    7a82:	fb 01       	movw	r30, r22
    7a84:	10 82       	st	Z, r1
    7a86:	cb 01       	movw	r24, r22
    7a88:	08 95       	ret

00007a8a <__itoa_ncheck>:
    7a8a:	bb 27       	eor	r27, r27
    7a8c:	4a 30       	cpi	r20, 0x0A	; 10
    7a8e:	31 f4       	brne	.+12     	; 0x7a9c <__itoa_ncheck+0x12>
    7a90:	99 23       	and	r25, r25
    7a92:	22 f4       	brpl	.+8      	; 0x7a9c <__itoa_ncheck+0x12>
    7a94:	bd e2       	ldi	r27, 0x2D	; 45
    7a96:	90 95       	com	r25
    7a98:	81 95       	neg	r24
    7a9a:	9f 4f       	sbci	r25, 0xFF	; 255
    7a9c:	0c 94 51 3d 	jmp	0x7aa2	; 0x7aa2 <__utoa_common>

00007aa0 <__utoa_ncheck>:
    7aa0:	bb 27       	eor	r27, r27

00007aa2 <__utoa_common>:
    7aa2:	fb 01       	movw	r30, r22
    7aa4:	55 27       	eor	r21, r21
    7aa6:	aa 27       	eor	r26, r26
    7aa8:	88 0f       	add	r24, r24
    7aaa:	99 1f       	adc	r25, r25
    7aac:	aa 1f       	adc	r26, r26
    7aae:	a4 17       	cp	r26, r20
    7ab0:	10 f0       	brcs	.+4      	; 0x7ab6 <__utoa_common+0x14>
    7ab2:	a4 1b       	sub	r26, r20
    7ab4:	83 95       	inc	r24
    7ab6:	50 51       	subi	r21, 0x10	; 16
    7ab8:	b9 f7       	brne	.-18     	; 0x7aa8 <__utoa_common+0x6>
    7aba:	a0 5d       	subi	r26, 0xD0	; 208
    7abc:	aa 33       	cpi	r26, 0x3A	; 58
    7abe:	08 f0       	brcs	.+2      	; 0x7ac2 <__utoa_common+0x20>
    7ac0:	a9 5d       	subi	r26, 0xD9	; 217
    7ac2:	a1 93       	st	Z+, r26
    7ac4:	00 97       	sbiw	r24, 0x00	; 0
    7ac6:	79 f7       	brne	.-34     	; 0x7aa6 <__utoa_common+0x4>
    7ac8:	b1 11       	cpse	r27, r1
    7aca:	b1 93       	st	Z+, r27
    7acc:	11 92       	st	Z+, r1
    7ace:	cb 01       	movw	r24, r22
    7ad0:	0c 94 6a 3d 	jmp	0x7ad4	; 0x7ad4 <strrev>

00007ad4 <strrev>:
    7ad4:	dc 01       	movw	r26, r24
    7ad6:	fc 01       	movw	r30, r24
    7ad8:	67 2f       	mov	r22, r23
    7ada:	71 91       	ld	r23, Z+
    7adc:	77 23       	and	r23, r23
    7ade:	e1 f7       	brne	.-8      	; 0x7ad8 <strrev+0x4>
    7ae0:	32 97       	sbiw	r30, 0x02	; 2
    7ae2:	04 c0       	rjmp	.+8      	; 0x7aec <strrev+0x18>
    7ae4:	7c 91       	ld	r23, X
    7ae6:	6d 93       	st	X+, r22
    7ae8:	70 83       	st	Z, r23
    7aea:	62 91       	ld	r22, -Z
    7aec:	ae 17       	cp	r26, r30
    7aee:	bf 07       	cpc	r27, r31
    7af0:	c8 f3       	brcs	.-14     	; 0x7ae4 <strrev+0x10>
    7af2:	08 95       	ret

00007af4 <eeprom_read_byte>:
    7af4:	e1 99       	sbic	0x1c, 1	; 28
    7af6:	fe cf       	rjmp	.-4      	; 0x7af4 <eeprom_read_byte>
    7af8:	9f bb       	out	0x1f, r25	; 31
    7afa:	8e bb       	out	0x1e, r24	; 30
    7afc:	e0 9a       	sbi	0x1c, 0	; 28
    7afe:	99 27       	eor	r25, r25
    7b00:	8d b3       	in	r24, 0x1d	; 29
    7b02:	08 95       	ret

00007b04 <eeprom_write_block>:
    7b04:	dc 01       	movw	r26, r24
    7b06:	cb 01       	movw	r24, r22
    7b08:	03 c0       	rjmp	.+6      	; 0x7b10 <eeprom_write_block+0xc>
    7b0a:	2d 91       	ld	r18, X+
    7b0c:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <eeprom_write_r18>
    7b10:	41 50       	subi	r20, 0x01	; 1
    7b12:	50 40       	sbci	r21, 0x00	; 0
    7b14:	d0 f7       	brcc	.-12     	; 0x7b0a <eeprom_write_block+0x6>
    7b16:	08 95       	ret

00007b18 <eeprom_write_byte>:
    7b18:	26 2f       	mov	r18, r22

00007b1a <eeprom_write_r18>:
    7b1a:	e1 99       	sbic	0x1c, 1	; 28
    7b1c:	fe cf       	rjmp	.-4      	; 0x7b1a <eeprom_write_r18>
    7b1e:	9f bb       	out	0x1f, r25	; 31
    7b20:	8e bb       	out	0x1e, r24	; 30
    7b22:	2d bb       	out	0x1d, r18	; 29
    7b24:	0f b6       	in	r0, 0x3f	; 63
    7b26:	f8 94       	cli
    7b28:	e2 9a       	sbi	0x1c, 2	; 28
    7b2a:	e1 9a       	sbi	0x1c, 1	; 28
    7b2c:	0f be       	out	0x3f, r0	; 63
    7b2e:	01 96       	adiw	r24, 0x01	; 1
    7b30:	08 95       	ret

00007b32 <_exit>:
    7b32:	f8 94       	cli

00007b34 <__stop_program>:
    7b34:	ff cf       	rjmp	.-2      	; 0x7b34 <__stop_program>
