
MCP2515.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b62  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00007b62  00000bf6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000032  00800076  00800076  00000c0c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c0c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000c3c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000230  00000000  00000000  00000c78  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002879  00000000  00000000  00000ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d91  00000000  00000000  00003721  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000013b4  00000000  00000000  000044b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005cc  00000000  00000000  00005868  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b96  00000000  00000000  00005e34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001916  00000000  00000000  000069ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001b0  00000000  00000000  000082e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 2a 38 	jmp	0x7054	; 0x7054 <__ctors_end>
    7004:	0c 94 f2 3a 	jmp	0x75e4	; 0x75e4 <__vector_1>
    7008:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    700c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7010:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7014:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7018:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    701c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7020:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7024:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7028:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    702c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7030:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7034:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7038:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    703c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7040:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7044:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7048:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    704c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7050:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>

00007054 <__ctors_end>:
    7054:	11 24       	eor	r1, r1
    7056:	1f be       	out	0x3f, r1	; 63
    7058:	cf e5       	ldi	r28, 0x5F	; 95
    705a:	d8 e0       	ldi	r29, 0x08	; 8
    705c:	de bf       	out	0x3e, r29	; 62
    705e:	cd bf       	out	0x3d, r28	; 61

00007060 <__do_copy_data>:
    7060:	10 e0       	ldi	r17, 0x00	; 0
    7062:	a0 e6       	ldi	r26, 0x60	; 96
    7064:	b0 e0       	ldi	r27, 0x00	; 0
    7066:	e2 e6       	ldi	r30, 0x62	; 98
    7068:	fb e7       	ldi	r31, 0x7B	; 123
    706a:	02 c0       	rjmp	.+4      	; 0x7070 <__do_copy_data+0x10>
    706c:	05 90       	lpm	r0, Z+
    706e:	0d 92       	st	X+, r0
    7070:	a6 37       	cpi	r26, 0x76	; 118
    7072:	b1 07       	cpc	r27, r17
    7074:	d9 f7       	brne	.-10     	; 0x706c <__do_copy_data+0xc>

00007076 <__do_clear_bss>:
    7076:	20 e0       	ldi	r18, 0x00	; 0
    7078:	a6 e7       	ldi	r26, 0x76	; 118
    707a:	b0 e0       	ldi	r27, 0x00	; 0
    707c:	01 c0       	rjmp	.+2      	; 0x7080 <.do_clear_bss_start>

0000707e <.do_clear_bss_loop>:
    707e:	1d 92       	st	X+, r1

00007080 <.do_clear_bss_start>:
    7080:	a8 3a       	cpi	r26, 0xA8	; 168
    7082:	b2 07       	cpc	r27, r18
    7084:	e1 f7       	brne	.-8      	; 0x707e <.do_clear_bss_loop>
    7086:	0e 94 5f 3a 	call	0x74be	; 0x74be <main>
    708a:	0c 94 af 3d 	jmp	0x7b5e	; 0x7b5e <_exit>

0000708e <__bad_interrupt>:
    708e:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

00007092 <EXTI_Init>:
 * brief this function used to enable and configure the selected INIT 
 * param : Handler is pointer to struct hold all INIT configurations 
 * return : void 
 */
void EXTI_Init(EXIT_Handler_t * Handler)
{
    7092:	fc 01       	movw	r30, r24
	
	if(Handler->EXTI_NUM == EXTI_NUM_2) /* INIT2 only available for edge detection */
    7094:	80 81       	ld	r24, Z
    7096:	81 11       	cpse	r24, r1
    7098:	0b c0       	rjmp	.+22     	; 0x70b0 <EXTI_Init+0x1e>
	{
		if(Handler->EXTI_EDGE_DETECTION == EXTI_EDGE_FAILING_EDGE)
    709a:	81 81       	ldd	r24, Z+1	; 0x01
    709c:	82 30       	cpi	r24, 0x02	; 2
    709e:	21 f4       	brne	.+8      	; 0x70a8 <EXTI_Init+0x16>
			MCUCSR &=~(1<<ISC2);
    70a0:	84 b7       	in	r24, 0x34	; 52
    70a2:	8f 7b       	andi	r24, 0xBF	; 191
    70a4:	84 bf       	out	0x34, r24	; 52
    70a6:	1d c0       	rjmp	.+58     	; 0x70e2 <EXTI_Init+0x50>
		else
			MCUCSR |= (1<<ISC2);
    70a8:	84 b7       	in	r24, 0x34	; 52
    70aa:	80 64       	ori	r24, 0x40	; 64
    70ac:	84 bf       	out	0x34, r24	; 52
    70ae:	19 c0       	rjmp	.+50     	; 0x70e2 <EXTI_Init+0x50>
		
	}else{   /* set configurations for INIT1 or INIT2  */
		
		MCUCR &=~(0x0f);
    70b0:	85 b7       	in	r24, 0x35	; 53
    70b2:	80 7f       	andi	r24, 0xF0	; 240
    70b4:	85 bf       	out	0x35, r24	; 53
		if(Handler->EXTI_NUM == EXTI_NUM_0)
    70b6:	20 81       	ld	r18, Z
    70b8:	21 30       	cpi	r18, 0x01	; 1
    70ba:	29 f4       	brne	.+10     	; 0x70c6 <EXTI_Init+0x34>
		{
		MCUCR |= Handler->EXTI_EDGE_DETECTION;
    70bc:	95 b7       	in	r25, 0x35	; 53
    70be:	81 81       	ldd	r24, Z+1	; 0x01
    70c0:	89 2b       	or	r24, r25
    70c2:	85 bf       	out	0x35, r24	; 53
    70c4:	0e c0       	rjmp	.+28     	; 0x70e2 <EXTI_Init+0x50>
		}
		else
		{
		MCUCR |= (Handler->EXTI_EDGE_DETECTION<<(2*Handler->EXTI_NUM));
    70c6:	45 b7       	in	r20, 0x35	; 53
    70c8:	91 81       	ldd	r25, Z+1	; 0x01
    70ca:	30 e0       	ldi	r19, 0x00	; 0
    70cc:	22 0f       	add	r18, r18
    70ce:	33 1f       	adc	r19, r19
    70d0:	89 2f       	mov	r24, r25
    70d2:	90 e0       	ldi	r25, 0x00	; 0
    70d4:	02 c0       	rjmp	.+4      	; 0x70da <EXTI_Init+0x48>
    70d6:	88 0f       	add	r24, r24
    70d8:	99 1f       	adc	r25, r25
    70da:	2a 95       	dec	r18
    70dc:	e2 f7       	brpl	.-8      	; 0x70d6 <EXTI_Init+0x44>
    70de:	84 2b       	or	r24, r20
    70e0:	85 bf       	out	0x35, r24	; 53
		}
		
	}
	
	
	GICR |= (1<<(5+Handler->EXTI_NUM));  /* enable the required INIT */
    70e2:	4b b7       	in	r20, 0x3b	; 59
    70e4:	20 81       	ld	r18, Z
    70e6:	30 e0       	ldi	r19, 0x00	; 0
    70e8:	2b 5f       	subi	r18, 0xFB	; 251
    70ea:	3f 4f       	sbci	r19, 0xFF	; 255
    70ec:	81 e0       	ldi	r24, 0x01	; 1
    70ee:	90 e0       	ldi	r25, 0x00	; 0
    70f0:	02 c0       	rjmp	.+4      	; 0x70f6 <EXTI_Init+0x64>
    70f2:	88 0f       	add	r24, r24
    70f4:	99 1f       	adc	r25, r25
    70f6:	2a 95       	dec	r18
    70f8:	e2 f7       	brpl	.-8      	; 0x70f2 <EXTI_Init+0x60>
    70fa:	84 2b       	or	r24, r20
    70fc:	8b bf       	out	0x3b, r24	; 59
	
	sei();
    70fe:	78 94       	sei
    7100:	08 95       	ret

00007102 <HAL_GPIO_INIT_PIN>:
	}
	else
	{
		return GPIO_PIN_RESET ;
	}
}
    7102:	dc 01       	movw	r26, r24
    7104:	fb 01       	movw	r30, r22
    7106:	81 81       	ldd	r24, Z+1	; 0x01
    7108:	81 30       	cpi	r24, 0x01	; 1
    710a:	99 f4       	brne	.+38     	; 0x7132 <HAL_GPIO_INIT_PIN+0x30>
    710c:	80 81       	ld	r24, Z
    710e:	11 96       	adiw	r26, 0x01	; 1
    7110:	9c 91       	ld	r25, X
    7112:	11 97       	sbiw	r26, 0x01	; 1
    7114:	89 2b       	or	r24, r25
    7116:	11 96       	adiw	r26, 0x01	; 1
    7118:	8c 93       	st	X, r24
    711a:	11 97       	sbiw	r26, 0x01	; 1
    711c:	82 81       	ldd	r24, Z+2	; 0x02
    711e:	81 30       	cpi	r24, 0x01	; 1
    7120:	81 f4       	brne	.+32     	; 0x7142 <HAL_GPIO_INIT_PIN+0x40>
    7122:	80 81       	ld	r24, Z
    7124:	12 96       	adiw	r26, 0x02	; 2
    7126:	9c 91       	ld	r25, X
    7128:	12 97       	sbiw	r26, 0x02	; 2
    712a:	89 2b       	or	r24, r25
    712c:	12 96       	adiw	r26, 0x02	; 2
    712e:	8c 93       	st	X, r24
    7130:	08 95       	ret
    7132:	90 81       	ld	r25, Z
    7134:	90 95       	com	r25
    7136:	11 96       	adiw	r26, 0x01	; 1
    7138:	8c 91       	ld	r24, X
    713a:	11 97       	sbiw	r26, 0x01	; 1
    713c:	98 23       	and	r25, r24
    713e:	11 96       	adiw	r26, 0x01	; 1
    7140:	9c 93       	st	X, r25
    7142:	08 95       	ret

00007144 <HAL_GPIO_WRITEPIN>:

void HAL_GPIO_WRITEPIN(GPIO_TypeDef * PORT,uint8_t PIN_NUM,GPIO_PinState PIN_STATE)
{
	if(PIN_STATE != GPIO_PIN_RESET)
    7144:	44 23       	and	r20, r20
    7146:	29 f0       	breq	.+10     	; 0x7152 <HAL_GPIO_WRITEPIN+0xe>
	{
		PORT->PORT_REG |= PIN_NUM ;
    7148:	fc 01       	movw	r30, r24
    714a:	22 81       	ldd	r18, Z+2	; 0x02
    714c:	62 2b       	or	r22, r18
    714e:	62 83       	std	Z+2, r22	; 0x02
    7150:	08 95       	ret
	}
	else
	{
		PORT->PORT_REG &= ~(PIN_NUM);
    7152:	60 95       	com	r22
    7154:	fc 01       	movw	r30, r24
    7156:	22 81       	ldd	r18, Z+2	; 0x02
    7158:	62 23       	and	r22, r18
    715a:	62 83       	std	Z+2, r22	; 0x02
    715c:	08 95       	ret

0000715e <HAL_GPIO_WRITEPORT>:
	}
	
}

void HAL_GPIO_WRITEPORT(GPIO_TypeDef * PORT,uint8_t PINS,GPIO_PinState PINS_STATE)
{
    715e:	fc 01       	movw	r30, r24
	PORT->PORT_REG &=~(PINS);
    7160:	60 95       	com	r22
    7162:	92 81       	ldd	r25, Z+2	; 0x02
    7164:	69 23       	and	r22, r25
	PORT->PORT_REG |=(PINS_STATE);
    7166:	46 2b       	or	r20, r22
    7168:	42 83       	std	Z+2, r20	; 0x02
    716a:	08 95       	ret

0000716c <HAL_SPI_Init>:
		while(!(SPI_PREPH->SPI_SPSR & SPI_SPSR_SPIF));  /* wait till the spi send byte and set SPIIF bit */
		++(Handler->RxBuffer);
		--(Handler->RxBufferSize);
	}	
	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_SET);	
}/* END_FUN HAL_SPI_Recieve()*/
    716c:	0f 93       	push	r16
    716e:	1f 93       	push	r17
    7170:	cf 93       	push	r28
    7172:	df 93       	push	r29
    7174:	00 d0       	rcall	.+0      	; 0x7176 <HAL_SPI_Init+0xa>
    7176:	1f 92       	push	r1
    7178:	cd b7       	in	r28, 0x3d	; 61
    717a:	de b7       	in	r29, 0x3e	; 62
    717c:	8c 01       	movw	r16, r24
    717e:	fc 01       	movw	r30, r24
    7180:	83 81       	ldd	r24, Z+3	; 0x03
    7182:	88 23       	and	r24, r24
    7184:	44 f4       	brge	.+16     	; 0x7196 <HAL_SPI_Init+0x2a>
    7186:	9d b1       	in	r25, 0x0d	; 13
    7188:	83 70       	andi	r24, 0x03	; 3
    718a:	89 2b       	or	r24, r25
    718c:	8d b9       	out	0x0d, r24	; 13
    718e:	8e b1       	in	r24, 0x0e	; 14
    7190:	81 60       	ori	r24, 0x01	; 1
    7192:	8e b9       	out	0x0e, r24	; 14
    7194:	04 c0       	rjmp	.+8      	; 0x719e <HAL_SPI_Init+0x32>
    7196:	9d b1       	in	r25, 0x0d	; 13
    7198:	83 70       	andi	r24, 0x03	; 3
    719a:	89 2b       	or	r24, r25
    719c:	8d b9       	out	0x0d, r24	; 13
    719e:	f8 01       	movw	r30, r16
    71a0:	80 81       	ld	r24, Z
    71a2:	84 ff       	sbrs	r24, 4
    71a4:	16 c0       	rjmp	.+44     	; 0x71d2 <HAL_SPI_Init+0x66>
    71a6:	81 e0       	ldi	r24, 0x01	; 1
    71a8:	8a 83       	std	Y+2, r24	; 0x02
    71aa:	80 eb       	ldi	r24, 0xB0	; 176
    71ac:	89 83       	std	Y+1, r24	; 0x01
    71ae:	be 01       	movw	r22, r28
    71b0:	6f 5f       	subi	r22, 0xFF	; 255
    71b2:	7f 4f       	sbci	r23, 0xFF	; 255
    71b4:	86 e3       	ldi	r24, 0x36	; 54
    71b6:	90 e0       	ldi	r25, 0x00	; 0
    71b8:	0e 94 81 38 	call	0x7102	; 0x7102 <HAL_GPIO_INIT_PIN>
    71bc:	1a 82       	std	Y+2, r1	; 0x02
    71be:	80 e4       	ldi	r24, 0x40	; 64
    71c0:	89 83       	std	Y+1, r24	; 0x01
    71c2:	be 01       	movw	r22, r28
    71c4:	6f 5f       	subi	r22, 0xFF	; 255
    71c6:	7f 4f       	sbci	r23, 0xFF	; 255
    71c8:	86 e3       	ldi	r24, 0x36	; 54
    71ca:	90 e0       	ldi	r25, 0x00	; 0
    71cc:	0e 94 81 38 	call	0x7102	; 0x7102 <HAL_GPIO_INIT_PIN>
    71d0:	15 c0       	rjmp	.+42     	; 0x71fc <HAL_SPI_Init+0x90>
    71d2:	1a 82       	std	Y+2, r1	; 0x02
    71d4:	80 eb       	ldi	r24, 0xB0	; 176
    71d6:	89 83       	std	Y+1, r24	; 0x01
    71d8:	be 01       	movw	r22, r28
    71da:	6f 5f       	subi	r22, 0xFF	; 255
    71dc:	7f 4f       	sbci	r23, 0xFF	; 255
    71de:	86 e3       	ldi	r24, 0x36	; 54
    71e0:	90 e0       	ldi	r25, 0x00	; 0
    71e2:	0e 94 81 38 	call	0x7102	; 0x7102 <HAL_GPIO_INIT_PIN>
    71e6:	81 e0       	ldi	r24, 0x01	; 1
    71e8:	8a 83       	std	Y+2, r24	; 0x02
    71ea:	80 e4       	ldi	r24, 0x40	; 64
    71ec:	89 83       	std	Y+1, r24	; 0x01
    71ee:	be 01       	movw	r22, r28
    71f0:	6f 5f       	subi	r22, 0xFF	; 255
    71f2:	7f 4f       	sbci	r23, 0xFF	; 255
    71f4:	86 e3       	ldi	r24, 0x36	; 54
    71f6:	90 e0       	ldi	r25, 0x00	; 0
    71f8:	0e 94 81 38 	call	0x7102	; 0x7102 <HAL_GPIO_INIT_PIN>
    71fc:	f8 01       	movw	r30, r16
    71fe:	42 81       	ldd	r20, Z+2	; 0x02
    7200:	81 81       	ldd	r24, Z+1	; 0x01
    7202:	34 81       	ldd	r19, Z+4	; 0x04
    7204:	25 81       	ldd	r18, Z+5	; 0x05
    7206:	90 81       	ld	r25, Z
    7208:	84 2b       	or	r24, r20
    720a:	83 2b       	or	r24, r19
    720c:	82 2b       	or	r24, r18
    720e:	89 2b       	or	r24, r25
    7210:	8d b9       	out	0x0d, r24	; 13
    7212:	8d b1       	in	r24, 0x0d	; 13
    7214:	80 64       	ori	r24, 0x40	; 64
    7216:	8d b9       	out	0x0d, r24	; 13
    7218:	85 81       	ldd	r24, Z+5	; 0x05
    721a:	80 38       	cpi	r24, 0x80	; 128
    721c:	09 f4       	brne	.+2      	; 0x7220 <HAL_SPI_Init+0xb4>
    721e:	78 94       	sei
    7220:	0f 90       	pop	r0
    7222:	0f 90       	pop	r0
    7224:	0f 90       	pop	r0
    7226:	df 91       	pop	r29
    7228:	cf 91       	pop	r28
    722a:	1f 91       	pop	r17
    722c:	0f 91       	pop	r16
    722e:	08 95       	ret

00007230 <HAL_SPI_Transmit>:
    7230:	cf 93       	push	r28
    7232:	df 93       	push	r29
    7234:	ec 01       	movw	r28, r24
    7236:	19 86       	std	Y+9, r1	; 0x09
    7238:	18 86       	std	Y+8, r1	; 0x08
    723a:	1d 86       	std	Y+13, r1	; 0x0d
    723c:	1c 86       	std	Y+12, r1	; 0x0c
    723e:	7f 83       	std	Y+7, r23	; 0x07
    7240:	6e 83       	std	Y+6, r22	; 0x06
    7242:	5b 87       	std	Y+11, r21	; 0x0b
    7244:	4a 87       	std	Y+10, r20	; 0x0a
    7246:	40 e0       	ldi	r20, 0x00	; 0
    7248:	60 e1       	ldi	r22, 0x10	; 16
    724a:	86 e3       	ldi	r24, 0x36	; 54
    724c:	90 e0       	ldi	r25, 0x00	; 0
    724e:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
    7252:	0b c0       	rjmp	.+22     	; 0x726a <HAL_SPI_Transmit+0x3a>
    7254:	ee 81       	ldd	r30, Y+6	; 0x06
    7256:	ff 81       	ldd	r31, Y+7	; 0x07
    7258:	80 81       	ld	r24, Z
    725a:	8f b9       	out	0x0f, r24	; 15
    725c:	77 9b       	sbis	0x0e, 7	; 14
    725e:	fe cf       	rjmp	.-4      	; 0x725c <HAL_SPI_Transmit+0x2c>
    7260:	8e 81       	ldd	r24, Y+6	; 0x06
    7262:	9f 81       	ldd	r25, Y+7	; 0x07
    7264:	01 96       	adiw	r24, 0x01	; 1
    7266:	9f 83       	std	Y+7, r25	; 0x07
    7268:	8e 83       	std	Y+6, r24	; 0x06
    726a:	8a 85       	ldd	r24, Y+10	; 0x0a
    726c:	9b 85       	ldd	r25, Y+11	; 0x0b
    726e:	9c 01       	movw	r18, r24
    7270:	21 50       	subi	r18, 0x01	; 1
    7272:	31 09       	sbc	r19, r1
    7274:	3b 87       	std	Y+11, r19	; 0x0b
    7276:	2a 87       	std	Y+10, r18	; 0x0a
    7278:	89 2b       	or	r24, r25
    727a:	61 f7       	brne	.-40     	; 0x7254 <HAL_SPI_Transmit+0x24>
    727c:	41 e0       	ldi	r20, 0x01	; 1
    727e:	60 e1       	ldi	r22, 0x10	; 16
    7280:	86 e3       	ldi	r24, 0x36	; 54
    7282:	90 e0       	ldi	r25, 0x00	; 0
    7284:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
    7288:	df 91       	pop	r29
    728a:	cf 91       	pop	r28
    728c:	08 95       	ret

0000728e <HAL_SPI_TransmitRecive>:
 * param. : pTxData --> pointer to the Tx buffer 
 * param. : pRxData --> pointer to the rx buffer
 * param. : size : the required number of bytes to received and transmit 
*/
 void HAL_SPI_TransmitRecive(SPI_Handler_t * Handler,uint8_t * pTxData,uint8_t * pRxData,uint16_t size )
{
    728e:	cf 93       	push	r28
    7290:	df 93       	push	r29
    7292:	ec 01       	movw	r28, r24
	Handler->RxBuffer = pRxData ;
    7294:	59 87       	std	Y+9, r21	; 0x09
    7296:	48 87       	std	Y+8, r20	; 0x08
	Handler->TxBuffer = pTxData  ;
    7298:	7f 83       	std	Y+7, r23	; 0x07
    729a:	6e 83       	std	Y+6, r22	; 0x06
	Handler->RxBufferSize = size ;
    729c:	3d 87       	std	Y+13, r19	; 0x0d
    729e:	2c 87       	std	Y+12, r18	; 0x0c
	Handler->TxBufferSize = size;
    72a0:	3b 87       	std	Y+11, r19	; 0x0b
    72a2:	2a 87       	std	Y+10, r18	; 0x0a

	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_RESET);
    72a4:	40 e0       	ldi	r20, 0x00	; 0
    72a6:	60 e1       	ldi	r22, 0x10	; 16
    72a8:	86 e3       	ldi	r24, 0x36	; 54
    72aa:	90 e0       	ldi	r25, 0x00	; 0
    72ac:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>

	while(Handler->RxBufferSize-- > 0)  /* block till end operation */
    72b0:	14 c0       	rjmp	.+40     	; 0x72da <HAL_SPI_TransmitRecive+0x4c>
	{

		SPI_PREPH->SPI_SPDR = *(Handler->TxBuffer);
    72b2:	ee 81       	ldd	r30, Y+6	; 0x06
    72b4:	ff 81       	ldd	r31, Y+7	; 0x07
    72b6:	80 81       	ld	r24, Z
    72b8:	8f b9       	out	0x0f, r24	; 15
		while(!(SPI_PREPH->SPI_SPSR & SPI_SPSR_SPIF));  /* wait till the SPI send byte and set SPIIF bit */
    72ba:	77 9b       	sbis	0x0e, 7	; 14
    72bc:	fe cf       	rjmp	.-4      	; 0x72ba <HAL_SPI_TransmitRecive+0x2c>
		*(Handler->RxBuffer) = SPI_PREPH->SPI_SPDR ;
    72be:	e8 85       	ldd	r30, Y+8	; 0x08
    72c0:	f9 85       	ldd	r31, Y+9	; 0x09
    72c2:	8f b1       	in	r24, 0x0f	; 15
    72c4:	80 83       	st	Z, r24
		++(Handler->RxBuffer);
    72c6:	88 85       	ldd	r24, Y+8	; 0x08
    72c8:	99 85       	ldd	r25, Y+9	; 0x09
    72ca:	01 96       	adiw	r24, 0x01	; 1
    72cc:	99 87       	std	Y+9, r25	; 0x09
    72ce:	88 87       	std	Y+8, r24	; 0x08
		++(Handler->TxBuffer);
    72d0:	8e 81       	ldd	r24, Y+6	; 0x06
    72d2:	9f 81       	ldd	r25, Y+7	; 0x07
    72d4:	01 96       	adiw	r24, 0x01	; 1
    72d6:	9f 83       	std	Y+7, r25	; 0x07
    72d8:	8e 83       	std	Y+6, r24	; 0x06
	Handler->RxBufferSize = size ;
	Handler->TxBufferSize = size;

	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_RESET);

	while(Handler->RxBufferSize-- > 0)  /* block till end operation */
    72da:	8c 85       	ldd	r24, Y+12	; 0x0c
    72dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    72de:	9c 01       	movw	r18, r24
    72e0:	21 50       	subi	r18, 0x01	; 1
    72e2:	31 09       	sbc	r19, r1
    72e4:	3d 87       	std	Y+13, r19	; 0x0d
    72e6:	2c 87       	std	Y+12, r18	; 0x0c
    72e8:	89 2b       	or	r24, r25
    72ea:	19 f7       	brne	.-58     	; 0x72b2 <HAL_SPI_TransmitRecive+0x24>
		*(Handler->RxBuffer) = SPI_PREPH->SPI_SPDR ;
		++(Handler->RxBuffer);
		++(Handler->TxBuffer);
		
	}	
	HAL_GPIO_WRITEPIN(GPIOB,SPI_PIN_SS,GPIO_PIN_SET);
    72ec:	41 e0       	ldi	r20, 0x01	; 1
    72ee:	60 e1       	ldi	r22, 0x10	; 16
    72f0:	86 e3       	ldi	r24, 0x36	; 54
    72f2:	90 e0       	ldi	r25, 0x00	; 0
    72f4:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
	
}/* END_FUN HAL_TransmitRecive()*/
    72f8:	df 91       	pop	r29
    72fa:	cf 91       	pop	r28
    72fc:	08 95       	ret

000072fe <LCD_Triger_Enable>:
	LCD_Goto_Location(y,x);
	HAL_GPIO_WRITEPIN(GPIOB,LCD_RS_GPIOB,GPIO_PIN_SET);
	HAL_GPIO_WRITEPIN(GPIOB,LCD_RW_GPIOB,GPIO_PIN_RESET);
	LCD_Send_4BitData(ch);
	
}
    72fe:	41 e0       	ldi	r20, 0x01	; 1
    7300:	68 e0       	ldi	r22, 0x08	; 8
    7302:	86 e3       	ldi	r24, 0x36	; 54
    7304:	90 e0       	ldi	r25, 0x00	; 0
    7306:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
    730a:	85 e0       	ldi	r24, 0x05	; 5
    730c:	8a 95       	dec	r24
    730e:	f1 f7       	brne	.-4      	; 0x730c <LCD_Triger_Enable+0xe>
    7310:	00 00       	nop
    7312:	40 e0       	ldi	r20, 0x00	; 0
    7314:	68 e0       	ldi	r22, 0x08	; 8
    7316:	86 e3       	ldi	r24, 0x36	; 54
    7318:	90 e0       	ldi	r25, 0x00	; 0
    731a:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
    731e:	8f e3       	ldi	r24, 0x3F	; 63
    7320:	9f e1       	ldi	r25, 0x1F	; 31
    7322:	01 97       	sbiw	r24, 0x01	; 1
    7324:	f1 f7       	brne	.-4      	; 0x7322 <LCD_Triger_Enable+0x24>
    7326:	00 c0       	rjmp	.+0      	; 0x7328 <LCD_Triger_Enable+0x2a>
    7328:	00 00       	nop
    732a:	08 95       	ret

0000732c <LCD_Send_4BitData>:
    732c:	cf 93       	push	r28
    732e:	c8 2f       	mov	r28, r24
    7330:	48 2f       	mov	r20, r24
    7332:	40 7f       	andi	r20, 0xF0	; 240
    7334:	60 ef       	ldi	r22, 0xF0	; 240
    7336:	89 e3       	ldi	r24, 0x39	; 57
    7338:	90 e0       	ldi	r25, 0x00	; 0
    733a:	0e 94 af 38 	call	0x715e	; 0x715e <HAL_GPIO_WRITEPORT>
    733e:	0e 94 7f 39 	call	0x72fe	; 0x72fe <LCD_Triger_Enable>
    7342:	80 e1       	ldi	r24, 0x10	; 16
    7344:	c8 9f       	mul	r28, r24
    7346:	a0 01       	movw	r20, r0
    7348:	11 24       	eor	r1, r1
    734a:	60 ef       	ldi	r22, 0xF0	; 240
    734c:	89 e3       	ldi	r24, 0x39	; 57
    734e:	90 e0       	ldi	r25, 0x00	; 0
    7350:	0e 94 af 38 	call	0x715e	; 0x715e <HAL_GPIO_WRITEPORT>
    7354:	0e 94 7f 39 	call	0x72fe	; 0x72fe <LCD_Triger_Enable>
    7358:	cf 91       	pop	r28
    735a:	08 95       	ret

0000735c <LCD_Send_A_Character_With_CurrLoc>:
    735c:	cf 93       	push	r28
    735e:	c8 2f       	mov	r28, r24
    7360:	41 e0       	ldi	r20, 0x01	; 1
    7362:	62 e0       	ldi	r22, 0x02	; 2
    7364:	86 e3       	ldi	r24, 0x36	; 54
    7366:	90 e0       	ldi	r25, 0x00	; 0
    7368:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
    736c:	40 e0       	ldi	r20, 0x00	; 0
    736e:	64 e0       	ldi	r22, 0x04	; 4
    7370:	86 e3       	ldi	r24, 0x36	; 54
    7372:	90 e0       	ldi	r25, 0x00	; 0
    7374:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
    7378:	8c 2f       	mov	r24, r28
    737a:	0e 94 96 39 	call	0x732c	; 0x732c <LCD_Send_4BitData>
    737e:	cf 91       	pop	r28
    7380:	08 95       	ret

00007382 <LCD_Send_A_Command>:
    7382:	cf 93       	push	r28
    7384:	c8 2f       	mov	r28, r24
    7386:	40 e0       	ldi	r20, 0x00	; 0
    7388:	66 e0       	ldi	r22, 0x06	; 6
    738a:	86 e3       	ldi	r24, 0x36	; 54
    738c:	90 e0       	ldi	r25, 0x00	; 0
    738e:	0e 94 a2 38 	call	0x7144	; 0x7144 <HAL_GPIO_WRITEPIN>
    7392:	8c 2f       	mov	r24, r28
    7394:	0e 94 96 39 	call	0x732c	; 0x732c <LCD_Send_4BitData>
    7398:	cf 91       	pop	r28
    739a:	08 95       	ret

0000739c <LCD_Goto_Location>:
    739c:	e8 2f       	mov	r30, r24
    739e:	f0 e0       	ldi	r31, 0x00	; 0
    73a0:	e1 5a       	subi	r30, 0xA1	; 161
    73a2:	ff 4f       	sbci	r31, 0xFF	; 255
    73a4:	80 81       	ld	r24, Z
    73a6:	86 0f       	add	r24, r22
    73a8:	81 50       	subi	r24, 0x01	; 1
    73aa:	0e 94 c1 39 	call	0x7382	; 0x7382 <LCD_Send_A_Command>
    73ae:	08 95       	ret

000073b0 <LCD_Initializaion>:
	LCD_Send_A_Command(column_position[y-1]+(x-1));
}


void LCD_Initializaion(void)
{
    73b0:	cf 93       	push	r28
    73b2:	df 93       	push	r29
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    73b4:	2f ef       	ldi	r18, 0xFF	; 255
    73b6:	89 ef       	ldi	r24, 0xF9	; 249
    73b8:	90 e0       	ldi	r25, 0x00	; 0
    73ba:	21 50       	subi	r18, 0x01	; 1
    73bc:	80 40       	sbci	r24, 0x00	; 0
    73be:	90 40       	sbci	r25, 0x00	; 0
    73c0:	e1 f7       	brne	.-8      	; 0x73ba <LCD_Initializaion+0xa>
    73c2:	00 c0       	rjmp	.+0      	; 0x73c4 <LCD_Initializaion+0x14>
    73c4:	00 00       	nop
	_delay_ms(20);
	// initialize portB pin 1,2,3 as output
	LCD_GPIO_Handler.mode = GPIO_MODE_OUTPUT ;
    73c6:	c6 e7       	ldi	r28, 0x76	; 118
    73c8:	d0 e0       	ldi	r29, 0x00	; 0
    73ca:	81 e0       	ldi	r24, 0x01	; 1
    73cc:	89 83       	std	Y+1, r24	; 0x01
	LCD_GPIO_Handler.pinS = LCD_RW_GPIOB |LCD_RS_GPIOB |LCD_EN_GPIOB ;
    73ce:	8e e0       	ldi	r24, 0x0E	; 14
    73d0:	88 83       	st	Y, r24
	LCD_GPIO_Handler.pull =GPIO_NOPULL ;
    73d2:	1a 82       	std	Y+2, r1	; 0x02
	HAL_GPIO_INIT_PIN(GPIOB,&LCD_GPIO_Handler);
    73d4:	be 01       	movw	r22, r28
    73d6:	86 e3       	ldi	r24, 0x36	; 54
    73d8:	90 e0       	ldi	r25, 0x00	; 0
    73da:	0e 94 81 38 	call	0x7102	; 0x7102 <HAL_GPIO_INIT_PIN>
	
	// initialize portA pin 4,5,6,7 as output	
	LCD_GPIO_Handler.pinS = LCD_D4_GPIOA|LCD_D5_GPIOA|LCD_D6_GPIOA|LCD_D7_GPIOA;
    73de:	80 ef       	ldi	r24, 0xF0	; 240
    73e0:	88 83       	st	Y, r24
	HAL_GPIO_INIT_PIN(GPIOA,&LCD_GPIO_Handler);
    73e2:	be 01       	movw	r22, r28
    73e4:	89 e3       	ldi	r24, 0x39	; 57
    73e6:	90 e0       	ldi	r25, 0x00	; 0
    73e8:	0e 94 81 38 	call	0x7102	; 0x7102 <HAL_GPIO_INIT_PIN>

	LCD_Send_A_Command(0x33U); // LCD initialization command 
    73ec:	83 e3       	ldi	r24, 0x33	; 51
    73ee:	0e 94 c1 39 	call	0x7382	; 0x7382 <LCD_Send_A_Command>
	LCD_Send_A_Command(0x32U);
    73f2:	82 e3       	ldi	r24, 0x32	; 50
    73f4:	0e 94 c1 39 	call	0x7382	; 0x7382 <LCD_Send_A_Command>
	LCD_Send_A_Command(LCD_2LINE_4_BIT_MODE);
    73f8:	88 e2       	ldi	r24, 0x28	; 40
    73fa:	0e 94 c1 39 	call	0x7382	; 0x7382 <LCD_Send_A_Command>
	LCD_Send_A_Command(LCD_COMMANED_CLEAR_CURSOR_OFF);
    73fe:	8c e0       	ldi	r24, 0x0C	; 12
    7400:	0e 94 c1 39 	call	0x7382	; 0x7382 <LCD_Send_A_Command>
	LCD_Send_A_Command(LCD_COMMANED_CLEAR_LCD);
    7404:	81 e0       	ldi	r24, 0x01	; 1
    7406:	0e 94 c1 39 	call	0x7382	; 0x7382 <LCD_Send_A_Command>
	
}
    740a:	df 91       	pop	r29
    740c:	cf 91       	pop	r28
    740e:	08 95       	ret

00007410 <LCD_Send_A_String_WithLoc>:

void LCD_Send_A_String_WithLoc(uint8_t y, uint8_t x, uint8_t *StringOfCharacters)
{
    7410:	cf 93       	push	r28
    7412:	df 93       	push	r29
    7414:	ea 01       	movw	r28, r20
	LCD_Goto_Location(y,x);
    7416:	0e 94 ce 39 	call	0x739c	; 0x739c <LCD_Goto_Location>
	while (*StringOfCharacters != 0)
    741a:	03 c0       	rjmp	.+6      	; 0x7422 <LCD_Send_A_String_WithLoc+0x12>
	{
		LCD_Send_A_Character_With_CurrLoc(*StringOfCharacters++);
    741c:	21 96       	adiw	r28, 0x01	; 1
    741e:	0e 94 ae 39 	call	0x735c	; 0x735c <LCD_Send_A_Character_With_CurrLoc>
}

void LCD_Send_A_String_WithLoc(uint8_t y, uint8_t x, uint8_t *StringOfCharacters)
{
	LCD_Goto_Location(y,x);
	while (*StringOfCharacters != 0)
    7422:	88 81       	ld	r24, Y
    7424:	81 11       	cpse	r24, r1
    7426:	fa cf       	rjmp	.-12     	; 0x741c <LCD_Send_A_String_WithLoc+0xc>
	{
		LCD_Send_A_Character_With_CurrLoc(*StringOfCharacters++);
	}
}
    7428:	df 91       	pop	r29
    742a:	cf 91       	pop	r28
    742c:	08 95       	ret

0000742e <LCD_Send_An_Integer_WithLoc>:

void LCD_Send_An_Integer_WithLoc(uint8_t y, uint8_t x, uint16_t IntegerToDisplay, uint8_t NumberOfDigits)
{
    742e:	8f 92       	push	r8
    7430:	9f 92       	push	r9
    7432:	af 92       	push	r10
    7434:	bf 92       	push	r11
    7436:	cf 92       	push	r12
    7438:	df 92       	push	r13
    743a:	ef 92       	push	r14
    743c:	ff 92       	push	r15
    743e:	0f 93       	push	r16
    7440:	1f 93       	push	r17
    7442:	cf 93       	push	r28
    7444:	df 93       	push	r29
    7446:	cd b7       	in	r28, 0x3d	; 61
    7448:	de b7       	in	r29, 0x3e	; 62
    744a:	98 2e       	mov	r9, r24
    744c:	86 2e       	mov	r8, r22
    744e:	ca 01       	movw	r24, r20
	itoa(IntegerToDisplay,StringToDisplay,10);
	for (uint16_t i=0;i<NumberOfDigits;i++)
	LCD_Send_A_Character_With_CurrLoc(' ');
	
	LCD_Send_A_String_WithLoc(y,x,StringToDisplay);
}
    7450:	ad b6       	in	r10, 0x3d	; 61
    7452:	be b6       	in	r11, 0x3e	; 62
	}
}

void LCD_Send_An_Integer_WithLoc(uint8_t y, uint8_t x, uint16_t IntegerToDisplay, uint8_t NumberOfDigits)
{
	uint8_t StringToDisplay[NumberOfDigits];
    7454:	e2 2e       	mov	r14, r18
    7456:	f1 2c       	mov	r15, r1
    7458:	2d b7       	in	r18, 0x3d	; 61
    745a:	3e b7       	in	r19, 0x3e	; 62
    745c:	2e 19       	sub	r18, r14
    745e:	3f 09       	sbc	r19, r15
    7460:	0f b6       	in	r0, 0x3f	; 63
    7462:	f8 94       	cli
    7464:	3e bf       	out	0x3e, r19	; 62
    7466:	0f be       	out	0x3f, r0	; 63
    7468:	2d bf       	out	0x3d, r18	; 61
    746a:	2f 5f       	subi	r18, 0xFF	; 255
    746c:	3f 4f       	sbci	r19, 0xFF	; 255
    746e:	69 01       	movw	r12, r18
	itoa(IntegerToDisplay,StringToDisplay,10);
    7470:	4a e0       	ldi	r20, 0x0A	; 10
    7472:	50 e0       	ldi	r21, 0x00	; 0
    7474:	b9 01       	movw	r22, r18
    7476:	0e 94 67 3d 	call	0x7ace	; 0x7ace <itoa>
	for (uint16_t i=0;i<NumberOfDigits;i++)
    747a:	00 e0       	ldi	r16, 0x00	; 0
    747c:	10 e0       	ldi	r17, 0x00	; 0
    747e:	05 c0       	rjmp	.+10     	; 0x748a <LCD_Send_An_Integer_WithLoc+0x5c>
	LCD_Send_A_Character_With_CurrLoc(' ');
    7480:	80 e2       	ldi	r24, 0x20	; 32
    7482:	0e 94 ae 39 	call	0x735c	; 0x735c <LCD_Send_A_Character_With_CurrLoc>

void LCD_Send_An_Integer_WithLoc(uint8_t y, uint8_t x, uint16_t IntegerToDisplay, uint8_t NumberOfDigits)
{
	uint8_t StringToDisplay[NumberOfDigits];
	itoa(IntegerToDisplay,StringToDisplay,10);
	for (uint16_t i=0;i<NumberOfDigits;i++)
    7486:	0f 5f       	subi	r16, 0xFF	; 255
    7488:	1f 4f       	sbci	r17, 0xFF	; 255
    748a:	0e 15       	cp	r16, r14
    748c:	1f 05       	cpc	r17, r15
    748e:	c0 f3       	brcs	.-16     	; 0x7480 <LCD_Send_An_Integer_WithLoc+0x52>
	LCD_Send_A_Character_With_CurrLoc(' ');
	
	LCD_Send_A_String_WithLoc(y,x,StringToDisplay);
    7490:	a6 01       	movw	r20, r12
    7492:	68 2d       	mov	r22, r8
    7494:	89 2d       	mov	r24, r9
    7496:	0e 94 08 3a 	call	0x7410	; 0x7410 <LCD_Send_A_String_WithLoc>
}
    749a:	0f b6       	in	r0, 0x3f	; 63
    749c:	f8 94       	cli
    749e:	be be       	out	0x3e, r11	; 62
    74a0:	0f be       	out	0x3f, r0	; 63
    74a2:	ad be       	out	0x3d, r10	; 61
    74a4:	df 91       	pop	r29
    74a6:	cf 91       	pop	r28
    74a8:	1f 91       	pop	r17
    74aa:	0f 91       	pop	r16
    74ac:	ff 90       	pop	r15
    74ae:	ef 90       	pop	r14
    74b0:	df 90       	pop	r13
    74b2:	cf 90       	pop	r12
    74b4:	bf 90       	pop	r11
    74b6:	af 90       	pop	r10
    74b8:	9f 90       	pop	r9
    74ba:	8f 90       	pop	r8
    74bc:	08 95       	ret

000074be <main>:
uint8_t counter ;
uint16_t  eepromadd ;
int main(void)
{
	/* vector table relocated to bootloader section */
		GICR = 1 << IVCE ; 
    74be:	81 e0       	ldi	r24, 0x01	; 1
    74c0:	8b bf       	out	0x3b, r24	; 59
		GICR = 1 << IVSEL ;
    74c2:	82 e0       	ldi	r24, 0x02	; 2
    74c4:	8b bf       	out	0x3b, r24	; 59
	DDRD = 0xe0;
    74c6:	80 ee       	ldi	r24, 0xE0	; 224
    74c8:	81 bb       	out	0x11, r24	; 17
	uint16_t Avr_Word =0; 
	unsigned char *buf = NULL;	
	
	
	
	MCP2515_init();   /* initialize the MCP2515 chip */
    74ca:	0e 94 c1 3c 	call	0x7982	; 0x7982 <MCP2515_init>
	LCD_Initializaion(); /* initialize LCD */
    74ce:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <LCD_Initializaion>
	
	
	uint8_t sreg;  /* Temp var to hold the status register value */
	uint32_t page_Num = 0; /* here we have 4 pages form 0 -3 */
	uint16_t Avr_Word =0; 
	unsigned char *buf = NULL;	
    74d2:	e1 2c       	mov	r14, r1
    74d4:	f1 2c       	mov	r15, r1
		//{
				//MCP2515_receiveMesg(&RecievedMesg);
				//eeprom_write_block(RecievedMesg.MesgData ,eepromadd ,8 );
				//eepromadd += 8;
				//counter++ ;
			LCD_Send_An_Integer_WithLoc(2,10,counter,3);
    74d6:	40 91 99 00 	lds	r20, 0x0099	; 0x800099 <counter>
    74da:	50 e0       	ldi	r21, 0x00	; 0
    74dc:	23 e0       	ldi	r18, 0x03	; 3
    74de:	6a e0       	ldi	r22, 0x0A	; 10
    74e0:	82 e0       	ldi	r24, 0x02	; 2
    74e2:	0e 94 17 3a 	call	0x742e	; 0x742e <LCD_Send_An_Integer_WithLoc>

		//}
		//
		/* now we received our message successfully so we need to carry out the boot operation */
		if (counter >= 22)
    74e6:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <counter>
    74ea:	86 31       	cpi	r24, 0x16	; 22
    74ec:	08 f4       	brcc	.+2      	; 0x74f0 <main+0x32>
    74ee:	6d c0       	rjmp	.+218    	; 0x75ca <main+0x10c>
		{

		/* Disable interrupts before start nay operation on the flash as explained in the data sheet */
		sreg = SREG;
    74f0:	5f b6       	in	r5, 0x3f	; 63
		cli();
    74f2:	f8 94       	cli
		
		/* flash the code */
		for ( page_Num =0;page_Num <4 ;page_Num++)	 /* iterate on the for pages */
    74f4:	81 2c       	mov	r8, r1
    74f6:	91 2c       	mov	r9, r1
    74f8:	54 01       	movw	r10, r8
    74fa:	51 c0       	rjmp	.+162    	; 0x759e <main+0xe0>
		{

			eeprom_busy_wait ();
    74fc:	e1 99       	sbic	0x1c, 1	; 28
    74fe:	fe cf       	rjmp	.-4      	; 0x74fc <main+0x3e>
			boot_page_erase_safe (page_Num*SPM_PAGESIZE);
    7500:	07 b6       	in	r0, 0x37	; 55
    7502:	00 fc       	sbrc	r0, 0
    7504:	fd cf       	rjmp	.-6      	; 0x7500 <main+0x42>
    7506:	e1 99       	sbic	0x1c, 1	; 28
    7508:	fe cf       	rjmp	.-4      	; 0x7506 <main+0x48>
    750a:	34 01       	movw	r6, r8
    750c:	76 94       	lsr	r7
    750e:	76 2c       	mov	r7, r6
    7510:	66 24       	eor	r6, r6
    7512:	77 94       	ror	r7
    7514:	67 94       	ror	r6
    7516:	83 e0       	ldi	r24, 0x03	; 3
    7518:	f3 01       	movw	r30, r6
    751a:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    751e:	e8 95       	spm
			boot_spm_busy_wait ();      /* Wait until the memory is erased */
    7520:	07 b6       	in	r0, 0x37	; 55
    7522:	00 fc       	sbrc	r0, 0
    7524:	fd cf       	rjmp	.-6      	; 0x7520 <main+0x62>
    7526:	00 e0       	ldi	r16, 0x00	; 0
    7528:	10 e0       	ldi	r17, 0x00	; 0
    752a:	1f c0       	rjmp	.+62     	; 0x756a <main+0xac>

			for (int iterator=0; iterator<SPM_PAGESIZE; iterator+=2) /* fill the temp buffer */
			{
				
				Avr_Word = eeprom_read_byte(buf++);
    752c:	c7 01       	movw	r24, r14
    752e:	0e 94 a7 3d 	call	0x7b4e	; 0x7b4e <eeprom_read_byte>
    7532:	c8 2f       	mov	r28, r24
    7534:	d0 e0       	ldi	r29, 0x00	; 0
				Avr_Word |= eeprom_read_byte(buf++) << 8;
    7536:	c7 01       	movw	r24, r14
    7538:	01 96       	adiw	r24, 0x01	; 1
    753a:	f2 e0       	ldi	r31, 0x02	; 2
    753c:	ef 0e       	add	r14, r31
    753e:	f1 1c       	adc	r15, r1
    7540:	0e 94 a7 3d 	call	0x7b4e	; 0x7b4e <eeprom_read_byte>
    7544:	90 e0       	ldi	r25, 0x00	; 0
    7546:	98 2f       	mov	r25, r24
    7548:	88 27       	eor	r24, r24
    754a:	8c 2b       	or	r24, r28
    754c:	9d 2b       	or	r25, r29
				
				boot_page_fill_safe (iterator, Avr_Word); /* write to the temp flash buffer */
    754e:	07 b6       	in	r0, 0x37	; 55
    7550:	00 fc       	sbrc	r0, 0
    7552:	fd cf       	rjmp	.-6      	; 0x754e <main+0x90>
    7554:	e1 99       	sbic	0x1c, 1	; 28
    7556:	fe cf       	rjmp	.-4      	; 0x7554 <main+0x96>
    7558:	21 e0       	ldi	r18, 0x01	; 1
    755a:	f6 01       	movw	r30, r12
    755c:	0c 01       	movw	r0, r24
    755e:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7562:	e8 95       	spm
    7564:	11 24       	eor	r1, r1

			eeprom_busy_wait ();
			boot_page_erase_safe (page_Num*SPM_PAGESIZE);
			boot_spm_busy_wait ();      /* Wait until the memory is erased */

			for (int iterator=0; iterator<SPM_PAGESIZE; iterator+=2) /* fill the temp buffer */
    7566:	0e 5f       	subi	r16, 0xFE	; 254
    7568:	1f 4f       	sbci	r17, 0xFF	; 255
    756a:	68 01       	movw	r12, r16
    756c:	00 38       	cpi	r16, 0x80	; 128
    756e:	11 05       	cpc	r17, r1
    7570:	e8 f2       	brcs	.-70     	; 0x752c <main+0x6e>
				Avr_Word = eeprom_read_byte(buf++);
				Avr_Word |= eeprom_read_byte(buf++) << 8;
				
				boot_page_fill_safe (iterator, Avr_Word); /* write to the temp flash buffer */
			}
			boot_page_write_safe (page_Num*SPM_PAGESIZE);     /* Store temp flash buffer in flash page */
    7572:	07 b6       	in	r0, 0x37	; 55
    7574:	00 fc       	sbrc	r0, 0
    7576:	fd cf       	rjmp	.-6      	; 0x7572 <main+0xb4>
    7578:	e1 99       	sbic	0x1c, 1	; 28
    757a:	fe cf       	rjmp	.-4      	; 0x7578 <main+0xba>
    757c:	85 e0       	ldi	r24, 0x05	; 5
    757e:	f3 01       	movw	r30, r6
    7580:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7584:	e8 95       	spm
			boot_spm_busy_wait();							 /* Wait until write operation is ended */
    7586:	07 b6       	in	r0, 0x37	; 55
    7588:	00 fc       	sbrc	r0, 0
    758a:	fd cf       	rjmp	.-6      	; 0x7586 <main+0xc8>
			boot_rww_enable ();
    758c:	81 e1       	ldi	r24, 0x11	; 17
    758e:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7592:	e8 95       	spm
		/* Disable interrupts before start nay operation on the flash as explained in the data sheet */
		sreg = SREG;
		cli();
		
		/* flash the code */
		for ( page_Num =0;page_Num <4 ;page_Num++)	 /* iterate on the for pages */
    7594:	ff ef       	ldi	r31, 0xFF	; 255
    7596:	8f 1a       	sub	r8, r31
    7598:	9f 0a       	sbc	r9, r31
    759a:	af 0a       	sbc	r10, r31
    759c:	bf 0a       	sbc	r11, r31
    759e:	24 e0       	ldi	r18, 0x04	; 4
    75a0:	82 16       	cp	r8, r18
    75a2:	91 04       	cpc	r9, r1
    75a4:	a1 04       	cpc	r10, r1
    75a6:	b1 04       	cpc	r11, r1
    75a8:	08 f4       	brcc	.+2      	; 0x75ac <main+0xee>
    75aa:	a8 cf       	rjmp	.-176    	; 0x74fc <main+0x3e>
			boot_rww_enable ();


		}
		/* branch to the application section in the flash */
			LCD_Send_A_String_WithLoc(1,3,"branching to ");
    75ac:	42 e6       	ldi	r20, 0x62	; 98
    75ae:	50 e0       	ldi	r21, 0x00	; 0
    75b0:	63 e0       	ldi	r22, 0x03	; 3
    75b2:	81 e0       	ldi	r24, 0x01	; 1
    75b4:	0e 94 08 3a 	call	0x7410	; 0x7410 <LCD_Send_A_String_WithLoc>
			LCD_Send_A_String_WithLoc(2,3,"image");
    75b8:	40 e7       	ldi	r20, 0x70	; 112
    75ba:	50 e0       	ldi	r21, 0x00	; 0
    75bc:	63 e0       	ldi	r22, 0x03	; 3
    75be:	82 e0       	ldi	r24, 0x02	; 2
    75c0:	0e 94 08 3a 	call	0x7410	; 0x7410 <LCD_Send_A_String_WithLoc>
		SREG = sreg;
    75c4:	5f be       	out	0x3f, r5	; 63
		asm ( "jmp 0x0000" );			
    75c6:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>
    75ca:	8f ef       	ldi	r24, 0xFF	; 255
    75cc:	93 ec       	ldi	r25, 0xC3	; 195
    75ce:	e9 e0       	ldi	r30, 0x09	; 9
    75d0:	81 50       	subi	r24, 0x01	; 1
    75d2:	90 40       	sbci	r25, 0x00	; 0
    75d4:	e0 40       	sbci	r30, 0x00	; 0
    75d6:	e1 f7       	brne	.-8      	; 0x75d0 <main+0x112>
    75d8:	00 c0       	rjmp	.+0      	; 0x75da <main+0x11c>
    75da:	00 00       	nop
			
		}
		
	_delay_ms(200);
		
		LCD_Send_A_Command(LCD_COMMANED_CLEAR_LCD);
    75dc:	81 e0       	ldi	r24, 0x01	; 1
    75de:	0e 94 c1 39 	call	0x7382	; 0x7382 <LCD_Send_A_Command>
    }
    75e2:	79 cf       	rjmp	.-270    	; 0x74d6 <main+0x18>

000075e4 <__vector_1>:
	return 0 ;
}

ISR(INT0_vect)
{
    75e4:	1f 92       	push	r1
    75e6:	0f 92       	push	r0
    75e8:	0f b6       	in	r0, 0x3f	; 63
    75ea:	0f 92       	push	r0
    75ec:	11 24       	eor	r1, r1
    75ee:	2f 93       	push	r18
    75f0:	3f 93       	push	r19
    75f2:	4f 93       	push	r20
    75f4:	5f 93       	push	r21
    75f6:	6f 93       	push	r22
    75f8:	7f 93       	push	r23
    75fa:	8f 93       	push	r24
    75fc:	9f 93       	push	r25
    75fe:	af 93       	push	r26
    7600:	bf 93       	push	r27
    7602:	ef 93       	push	r30
    7604:	ff 93       	push	r31

	counter++;
    7606:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <counter>
    760a:	8f 5f       	subi	r24, 0xFF	; 255
    760c:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <counter>

	MCP2515_receiveMesg(&RecievedMesg);
    7610:	8b e8       	ldi	r24, 0x8B	; 139
    7612:	90 e0       	ldi	r25, 0x00	; 0
    7614:	0e 94 f6 3c 	call	0x79ec	; 0x79ec <MCP2515_receiveMesg>
	
	PORTD = 0x80;
    7618:	80 e8       	ldi	r24, 0x80	; 128
    761a:	82 bb       	out	0x12, r24	; 18

    761c:	ff 91       	pop	r31
    761e:	ef 91       	pop	r30
    7620:	bf 91       	pop	r27
    7622:	af 91       	pop	r26
    7624:	9f 91       	pop	r25
    7626:	8f 91       	pop	r24
    7628:	7f 91       	pop	r23
    762a:	6f 91       	pop	r22
    762c:	5f 91       	pop	r21
    762e:	4f 91       	pop	r20
    7630:	3f 91       	pop	r19
    7632:	2f 91       	pop	r18
    7634:	0f 90       	pop	r0
    7636:	0f be       	out	0x3f, r0	; 63
    7638:	0f 90       	pop	r0
    763a:	1f 90       	pop	r1
    763c:	18 95       	reti

0000763e <MCP2515_Read_Register>:
	dataTx[0] = 0x81+TXnum;
	HAL_SPI_Transmit(&MCP2515_SPIHandler,dataTx,1);
	
	
	
}/* END_FUN MCP2515_SendCANmsg() */
    763e:	cf 93       	push	r28
    7640:	df 93       	push	r29
    7642:	00 d0       	rcall	.+0      	; 0x7644 <MCP2515_Read_Register+0x6>
    7644:	1f 92       	push	r1
    7646:	cd b7       	in	r28, 0x3d	; 61
    7648:	de b7       	in	r29, 0x3e	; 62
    764a:	93 e0       	ldi	r25, 0x03	; 3
    764c:	99 83       	std	Y+1, r25	; 0x01
    764e:	8a 83       	std	Y+2, r24	; 0x02
    7650:	1b 82       	std	Y+3, r1	; 0x03
    7652:	23 e0       	ldi	r18, 0x03	; 3
    7654:	30 e0       	ldi	r19, 0x00	; 0
    7656:	ae 01       	movw	r20, r28
    7658:	4f 5f       	subi	r20, 0xFF	; 255
    765a:	5f 4f       	sbci	r21, 0xFF	; 255
    765c:	ba 01       	movw	r22, r20
    765e:	8b e7       	ldi	r24, 0x7B	; 123
    7660:	90 e0       	ldi	r25, 0x00	; 0
    7662:	0e 94 47 39 	call	0x728e	; 0x728e <HAL_SPI_TransmitRecive>
    7666:	8b 81       	ldd	r24, Y+3	; 0x03
    7668:	0f 90       	pop	r0
    766a:	0f 90       	pop	r0
    766c:	0f 90       	pop	r0
    766e:	df 91       	pop	r29
    7670:	cf 91       	pop	r28
    7672:	08 95       	ret

00007674 <MCP2515_Write_Register>:
    7674:	cf 93       	push	r28
    7676:	df 93       	push	r29
    7678:	00 d0       	rcall	.+0      	; 0x767a <MCP2515_Write_Register+0x6>
    767a:	1f 92       	push	r1
    767c:	cd b7       	in	r28, 0x3d	; 61
    767e:	de b7       	in	r29, 0x3e	; 62
    7680:	92 e0       	ldi	r25, 0x02	; 2
    7682:	99 83       	std	Y+1, r25	; 0x01
    7684:	8a 83       	std	Y+2, r24	; 0x02
    7686:	6b 83       	std	Y+3, r22	; 0x03
    7688:	43 e0       	ldi	r20, 0x03	; 3
    768a:	50 e0       	ldi	r21, 0x00	; 0
    768c:	be 01       	movw	r22, r28
    768e:	6f 5f       	subi	r22, 0xFF	; 255
    7690:	7f 4f       	sbci	r23, 0xFF	; 255
    7692:	8b e7       	ldi	r24, 0x7B	; 123
    7694:	90 e0       	ldi	r25, 0x00	; 0
    7696:	0e 94 18 39 	call	0x7230	; 0x7230 <HAL_SPI_Transmit>
    769a:	0f 90       	pop	r0
    769c:	0f 90       	pop	r0
    769e:	0f 90       	pop	r0
    76a0:	df 91       	pop	r29
    76a2:	cf 91       	pop	r28
    76a4:	08 95       	ret

000076a6 <MCP2515_Rest>:
    76a6:	cf 93       	push	r28
    76a8:	df 93       	push	r29
    76aa:	1f 92       	push	r1
    76ac:	cd b7       	in	r28, 0x3d	; 61
    76ae:	de b7       	in	r29, 0x3e	; 62
    76b0:	80 ec       	ldi	r24, 0xC0	; 192
    76b2:	89 83       	std	Y+1, r24	; 0x01
    76b4:	41 e0       	ldi	r20, 0x01	; 1
    76b6:	50 e0       	ldi	r21, 0x00	; 0
    76b8:	be 01       	movw	r22, r28
    76ba:	6f 5f       	subi	r22, 0xFF	; 255
    76bc:	7f 4f       	sbci	r23, 0xFF	; 255
    76be:	8b e7       	ldi	r24, 0x7B	; 123
    76c0:	90 e0       	ldi	r25, 0x00	; 0
    76c2:	0e 94 18 39 	call	0x7230	; 0x7230 <HAL_SPI_Transmit>
    76c6:	2f ef       	ldi	r18, 0xFF	; 255
    76c8:	89 ef       	ldi	r24, 0xF9	; 249
    76ca:	90 e0       	ldi	r25, 0x00	; 0
    76cc:	21 50       	subi	r18, 0x01	; 1
    76ce:	80 40       	sbci	r24, 0x00	; 0
    76d0:	90 40       	sbci	r25, 0x00	; 0
    76d2:	e1 f7       	brne	.-8      	; 0x76cc <MCP2515_Rest+0x26>
    76d4:	00 c0       	rjmp	.+0      	; 0x76d6 <MCP2515_Rest+0x30>
    76d6:	00 00       	nop
    76d8:	0f 90       	pop	r0
    76da:	df 91       	pop	r29
    76dc:	cf 91       	pop	r28
    76de:	08 95       	ret

000076e0 <MCP2515_SetBitTiming>:
    76e0:	cf 93       	push	r28
    76e2:	df 93       	push	r29
    76e4:	d6 2f       	mov	r29, r22
    76e6:	c4 2f       	mov	r28, r20
    76e8:	68 2f       	mov	r22, r24
    76ea:	8a e2       	ldi	r24, 0x2A	; 42
    76ec:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    76f0:	6d 2f       	mov	r22, r29
    76f2:	89 e2       	ldi	r24, 0x29	; 41
    76f4:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    76f8:	6c 2f       	mov	r22, r28
    76fa:	88 e2       	ldi	r24, 0x28	; 40
    76fc:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    7700:	df 91       	pop	r29
    7702:	cf 91       	pop	r28
    7704:	08 95       	ret

00007706 <MCP2515_Set_OperMode>:
    7706:	cf 93       	push	r28
    7708:	df 93       	push	r29
    770a:	00 d0       	rcall	.+0      	; 0x770c <MCP2515_Set_OperMode+0x6>
    770c:	1f 92       	push	r1
    770e:	cd b7       	in	r28, 0x3d	; 61
    7710:	de b7       	in	r29, 0x3e	; 62
    7712:	92 e0       	ldi	r25, 0x02	; 2
    7714:	99 83       	std	Y+1, r25	; 0x01
    7716:	9f e0       	ldi	r25, 0x0F	; 15
    7718:	9a 83       	std	Y+2, r25	; 0x02
    771a:	8b 83       	std	Y+3, r24	; 0x03
    771c:	43 e0       	ldi	r20, 0x03	; 3
    771e:	50 e0       	ldi	r21, 0x00	; 0
    7720:	be 01       	movw	r22, r28
    7722:	6f 5f       	subi	r22, 0xFF	; 255
    7724:	7f 4f       	sbci	r23, 0xFF	; 255
    7726:	8b e7       	ldi	r24, 0x7B	; 123
    7728:	90 e0       	ldi	r25, 0x00	; 0
    772a:	0e 94 18 39 	call	0x7230	; 0x7230 <HAL_SPI_Transmit>
    772e:	0f 90       	pop	r0
    7730:	0f 90       	pop	r0
    7732:	0f 90       	pop	r0
    7734:	df 91       	pop	r29
    7736:	cf 91       	pop	r28
    7738:	08 95       	ret

0000773a <MCP2515_SetMask>:
    773a:	cf 92       	push	r12
    773c:	df 92       	push	r13
    773e:	ef 92       	push	r14
    7740:	ff 92       	push	r15
    7742:	cf 93       	push	r28
    7744:	c8 2f       	mov	r28, r24
    7746:	6a 01       	movw	r12, r20
    7748:	7b 01       	movw	r14, r22
    774a:	22 23       	and	r18, r18
    774c:	09 f4       	brne	.+2      	; 0x7750 <MCP2515_SetMask+0x16>
    774e:	4a c0       	rjmp	.+148    	; 0x77e4 <MCP2515_SetMask+0xaa>
    7750:	cb 01       	movw	r24, r22
    7752:	ba 01       	movw	r22, r20
    7754:	68 94       	set
    7756:	12 f8       	bld	r1, 2
    7758:	96 95       	lsr	r25
    775a:	87 95       	ror	r24
    775c:	77 95       	ror	r23
    775e:	67 95       	ror	r22
    7760:	16 94       	lsr	r1
    7762:	d1 f7       	brne	.-12     	; 0x7758 <MCP2515_SetMask+0x1e>
    7764:	2c 2f       	mov	r18, r28
    7766:	30 e0       	ldi	r19, 0x00	; 0
    7768:	28 5f       	subi	r18, 0xF8	; 248
    776a:	3f 4f       	sbci	r19, 0xFF	; 255
    776c:	82 2f       	mov	r24, r18
    776e:	88 0f       	add	r24, r24
    7770:	88 0f       	add	r24, r24
    7772:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    7776:	d7 01       	movw	r26, r14
    7778:	c6 01       	movw	r24, r12
    777a:	07 2e       	mov	r0, r23
    777c:	7b e1       	ldi	r23, 0x1B	; 27
    777e:	b6 95       	lsr	r27
    7780:	a7 95       	ror	r26
    7782:	97 95       	ror	r25
    7784:	87 95       	ror	r24
    7786:	7a 95       	dec	r23
    7788:	d1 f7       	brne	.-12     	; 0x777e <MCP2515_SetMask+0x44>
    778a:	70 2d       	mov	r23, r0
    778c:	cc 0f       	add	r28, r28
    778e:	cc 0f       	add	r28, r28
    7790:	6c 2d       	mov	r22, r12
    7792:	62 95       	swap	r22
    7794:	66 0f       	add	r22, r22
    7796:	60 7e       	andi	r22, 0xE0	; 224
    7798:	86 2b       	or	r24, r22
    779a:	68 2f       	mov	r22, r24
    779c:	68 60       	ori	r22, 0x08	; 8
    779e:	81 e2       	ldi	r24, 0x21	; 33
    77a0:	8c 0f       	add	r24, r28
    77a2:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    77a6:	c7 01       	movw	r24, r14
    77a8:	b6 01       	movw	r22, r12
    77aa:	05 2e       	mov	r0, r21
    77ac:	5b e0       	ldi	r21, 0x0B	; 11
    77ae:	96 95       	lsr	r25
    77b0:	87 95       	ror	r24
    77b2:	77 95       	ror	r23
    77b4:	67 95       	ror	r22
    77b6:	5a 95       	dec	r21
    77b8:	d1 f7       	brne	.-12     	; 0x77ae <MCP2515_SetMask+0x74>
    77ba:	50 2d       	mov	r21, r0
    77bc:	83 e2       	ldi	r24, 0x23	; 35
    77be:	8c 0f       	add	r24, r28
    77c0:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    77c4:	c7 01       	movw	r24, r14
    77c6:	b6 01       	movw	r22, r12
    77c8:	05 2e       	mov	r0, r21
    77ca:	53 e1       	ldi	r21, 0x13	; 19
    77cc:	96 95       	lsr	r25
    77ce:	87 95       	ror	r24
    77d0:	77 95       	ror	r23
    77d2:	67 95       	ror	r22
    77d4:	5a 95       	dec	r21
    77d6:	d1 f7       	brne	.-12     	; 0x77cc <MCP2515_SetMask+0x92>
    77d8:	50 2d       	mov	r21, r0
    77da:	82 e2       	ldi	r24, 0x22	; 34
    77dc:	8c 0f       	add	r24, r28
    77de:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    77e2:	1d c0       	rjmp	.+58     	; 0x781e <MCP2515_SetMask+0xe4>
    77e4:	cb 01       	movw	r24, r22
    77e6:	ba 01       	movw	r22, r20
    77e8:	68 94       	set
    77ea:	12 f8       	bld	r1, 2
    77ec:	96 95       	lsr	r25
    77ee:	87 95       	ror	r24
    77f0:	77 95       	ror	r23
    77f2:	67 95       	ror	r22
    77f4:	16 94       	lsr	r1
    77f6:	d1 f7       	brne	.-12     	; 0x77ec <MCP2515_SetMask+0xb2>
    77f8:	2c 2f       	mov	r18, r28
    77fa:	30 e0       	ldi	r19, 0x00	; 0
    77fc:	28 5f       	subi	r18, 0xF8	; 248
    77fe:	3f 4f       	sbci	r19, 0xFF	; 255
    7800:	82 2f       	mov	r24, r18
    7802:	88 0f       	add	r24, r24
    7804:	88 0f       	add	r24, r24
    7806:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    780a:	6c 2d       	mov	r22, r12
    780c:	62 95       	swap	r22
    780e:	66 0f       	add	r22, r22
    7810:	60 7e       	andi	r22, 0xE0	; 224
    7812:	8c 2f       	mov	r24, r28
    7814:	88 0f       	add	r24, r24
    7816:	88 0f       	add	r24, r24
    7818:	8f 5d       	subi	r24, 0xDF	; 223
    781a:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    781e:	cf 91       	pop	r28
    7820:	ff 90       	pop	r15
    7822:	ef 90       	pop	r14
    7824:	df 90       	pop	r13
    7826:	cf 90       	pop	r12
    7828:	08 95       	ret

0000782a <MCP2515_SetFilter>:
    782a:	cf 92       	push	r12
    782c:	df 92       	push	r13
    782e:	ef 92       	push	r14
    7830:	ff 92       	push	r15
    7832:	cf 93       	push	r28
    7834:	df 93       	push	r29
    7836:	c8 2f       	mov	r28, r24
    7838:	6a 01       	movw	r12, r20
    783a:	7b 01       	movw	r14, r22
    783c:	22 23       	and	r18, r18
    783e:	09 f4       	brne	.+2      	; 0x7842 <MCP2515_SetFilter+0x18>
    7840:	5c c0       	rjmp	.+184    	; 0x78fa <MCP2515_SetFilter+0xd0>
    7842:	cb 01       	movw	r24, r22
    7844:	ba 01       	movw	r22, r20
    7846:	68 94       	set
    7848:	12 f8       	bld	r1, 2
    784a:	96 95       	lsr	r25
    784c:	87 95       	ror	r24
    784e:	77 95       	ror	r23
    7850:	67 95       	ror	r22
    7852:	16 94       	lsr	r1
    7854:	d1 f7       	brne	.-12     	; 0x784a <MCP2515_SetFilter+0x20>
    7856:	dc 2f       	mov	r29, r28
    7858:	dd 0f       	add	r29, r29
    785a:	dd 0f       	add	r29, r29
    785c:	c3 30       	cpi	r28, 0x03	; 3
    785e:	10 f0       	brcs	.+4      	; 0x7864 <MCP2515_SetFilter+0x3a>
    7860:	24 e0       	ldi	r18, 0x04	; 4
    7862:	01 c0       	rjmp	.+2      	; 0x7866 <MCP2515_SetFilter+0x3c>
    7864:	20 e0       	ldi	r18, 0x00	; 0
    7866:	82 2f       	mov	r24, r18
    7868:	8d 0f       	add	r24, r29
    786a:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    786e:	8c 2d       	mov	r24, r12
    7870:	82 95       	swap	r24
    7872:	88 0f       	add	r24, r24
    7874:	80 7e       	andi	r24, 0xE0	; 224
    7876:	b7 01       	movw	r22, r14
    7878:	a6 01       	movw	r20, r12
    787a:	03 2e       	mov	r0, r19
    787c:	3b e1       	ldi	r19, 0x1B	; 27
    787e:	76 95       	lsr	r23
    7880:	67 95       	ror	r22
    7882:	57 95       	ror	r21
    7884:	47 95       	ror	r20
    7886:	3a 95       	dec	r19
    7888:	d1 f7       	brne	.-12     	; 0x787e <MCP2515_SetFilter+0x54>
    788a:	30 2d       	mov	r19, r0
    788c:	48 2b       	or	r20, r24
    788e:	64 2f       	mov	r22, r20
    7890:	68 60       	ori	r22, 0x08	; 8
    7892:	c3 30       	cpi	r28, 0x03	; 3
    7894:	10 f0       	brcs	.+4      	; 0x789a <MCP2515_SetFilter+0x70>
    7896:	84 e0       	ldi	r24, 0x04	; 4
    7898:	01 c0       	rjmp	.+2      	; 0x789c <MCP2515_SetFilter+0x72>
    789a:	80 e0       	ldi	r24, 0x00	; 0
    789c:	8d 0f       	add	r24, r29
    789e:	8f 5f       	subi	r24, 0xFF	; 255
    78a0:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    78a4:	c7 01       	movw	r24, r14
    78a6:	b6 01       	movw	r22, r12
    78a8:	05 2e       	mov	r0, r21
    78aa:	5b e0       	ldi	r21, 0x0B	; 11
    78ac:	96 95       	lsr	r25
    78ae:	87 95       	ror	r24
    78b0:	77 95       	ror	r23
    78b2:	67 95       	ror	r22
    78b4:	5a 95       	dec	r21
    78b6:	d1 f7       	brne	.-12     	; 0x78ac <MCP2515_SetFilter+0x82>
    78b8:	50 2d       	mov	r21, r0
    78ba:	c3 30       	cpi	r28, 0x03	; 3
    78bc:	10 f0       	brcs	.+4      	; 0x78c2 <MCP2515_SetFilter+0x98>
    78be:	24 e0       	ldi	r18, 0x04	; 4
    78c0:	01 c0       	rjmp	.+2      	; 0x78c4 <MCP2515_SetFilter+0x9a>
    78c2:	20 e0       	ldi	r18, 0x00	; 0
    78c4:	2d 0f       	add	r18, r29
    78c6:	83 e0       	ldi	r24, 0x03	; 3
    78c8:	82 0f       	add	r24, r18
    78ca:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    78ce:	c7 01       	movw	r24, r14
    78d0:	b6 01       	movw	r22, r12
    78d2:	05 2e       	mov	r0, r21
    78d4:	53 e1       	ldi	r21, 0x13	; 19
    78d6:	96 95       	lsr	r25
    78d8:	87 95       	ror	r24
    78da:	77 95       	ror	r23
    78dc:	67 95       	ror	r22
    78de:	5a 95       	dec	r21
    78e0:	d1 f7       	brne	.-12     	; 0x78d6 <MCP2515_SetFilter+0xac>
    78e2:	50 2d       	mov	r21, r0
    78e4:	c3 30       	cpi	r28, 0x03	; 3
    78e6:	10 f0       	brcs	.+4      	; 0x78ec <MCP2515_SetFilter+0xc2>
    78e8:	24 e0       	ldi	r18, 0x04	; 4
    78ea:	01 c0       	rjmp	.+2      	; 0x78ee <MCP2515_SetFilter+0xc4>
    78ec:	20 e0       	ldi	r18, 0x00	; 0
    78ee:	2d 0f       	add	r18, r29
    78f0:	82 e0       	ldi	r24, 0x02	; 2
    78f2:	82 0f       	add	r24, r18
    78f4:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    78f8:	23 c0       	rjmp	.+70     	; 0x7940 <MCP2515_SetFilter+0x116>
    78fa:	cb 01       	movw	r24, r22
    78fc:	ba 01       	movw	r22, r20
    78fe:	68 94       	set
    7900:	12 f8       	bld	r1, 2
    7902:	96 95       	lsr	r25
    7904:	87 95       	ror	r24
    7906:	77 95       	ror	r23
    7908:	67 95       	ror	r22
    790a:	16 94       	lsr	r1
    790c:	d1 f7       	brne	.-12     	; 0x7902 <MCP2515_SetFilter+0xd8>
    790e:	dc 2f       	mov	r29, r28
    7910:	dd 0f       	add	r29, r29
    7912:	dd 0f       	add	r29, r29
    7914:	c3 30       	cpi	r28, 0x03	; 3
    7916:	10 f0       	brcs	.+4      	; 0x791c <MCP2515_SetFilter+0xf2>
    7918:	24 e0       	ldi	r18, 0x04	; 4
    791a:	01 c0       	rjmp	.+2      	; 0x791e <MCP2515_SetFilter+0xf4>
    791c:	20 e0       	ldi	r18, 0x00	; 0
    791e:	82 2f       	mov	r24, r18
    7920:	8d 0f       	add	r24, r29
    7922:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    7926:	6c 2d       	mov	r22, r12
    7928:	62 95       	swap	r22
    792a:	66 0f       	add	r22, r22
    792c:	60 7e       	andi	r22, 0xE0	; 224
    792e:	c3 30       	cpi	r28, 0x03	; 3
    7930:	10 f0       	brcs	.+4      	; 0x7936 <MCP2515_SetFilter+0x10c>
    7932:	84 e0       	ldi	r24, 0x04	; 4
    7934:	01 c0       	rjmp	.+2      	; 0x7938 <MCP2515_SetFilter+0x10e>
    7936:	80 e0       	ldi	r24, 0x00	; 0
    7938:	8d 0f       	add	r24, r29
    793a:	8f 5f       	subi	r24, 0xFF	; 255
    793c:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    7940:	df 91       	pop	r29
    7942:	cf 91       	pop	r28
    7944:	ff 90       	pop	r15
    7946:	ef 90       	pop	r14
    7948:	df 90       	pop	r13
    794a:	cf 90       	pop	r12
    794c:	08 95       	ret

0000794e <MCP2515_Enable_Interrupt>:
    794e:	cf 93       	push	r28
    7950:	df 93       	push	r29
    7952:	00 d0       	rcall	.+0      	; 0x7954 <MCP2515_Enable_Interrupt+0x6>
    7954:	1f 92       	push	r1
    7956:	cd b7       	in	r28, 0x3d	; 61
    7958:	de b7       	in	r29, 0x3e	; 62
    795a:	92 e0       	ldi	r25, 0x02	; 2
    795c:	99 83       	std	Y+1, r25	; 0x01
    795e:	9b e2       	ldi	r25, 0x2B	; 43
    7960:	9a 83       	std	Y+2, r25	; 0x02
    7962:	8b 83       	std	Y+3, r24	; 0x03
    7964:	43 e0       	ldi	r20, 0x03	; 3
    7966:	50 e0       	ldi	r21, 0x00	; 0
    7968:	be 01       	movw	r22, r28
    796a:	6f 5f       	subi	r22, 0xFF	; 255
    796c:	7f 4f       	sbci	r23, 0xFF	; 255
    796e:	8b e7       	ldi	r24, 0x7B	; 123
    7970:	90 e0       	ldi	r25, 0x00	; 0
    7972:	0e 94 18 39 	call	0x7230	; 0x7230 <HAL_SPI_Transmit>
    7976:	0f 90       	pop	r0
    7978:	0f 90       	pop	r0
    797a:	0f 90       	pop	r0
    797c:	df 91       	pop	r29
    797e:	cf 91       	pop	r28
    7980:	08 95       	ret

00007982 <MCP2515_init>:
    7982:	e9 e7       	ldi	r30, 0x79	; 121
    7984:	f0 e0       	ldi	r31, 0x00	; 0
    7986:	81 e0       	ldi	r24, 0x01	; 1
    7988:	80 83       	st	Z, r24
    798a:	11 82       	std	Z+1, r1	; 0x01
    798c:	eb e7       	ldi	r30, 0x7B	; 123
    798e:	f0 e0       	ldi	r31, 0x00	; 0
    7990:	80 e1       	ldi	r24, 0x10	; 16
    7992:	80 83       	st	Z, r24
    7994:	84 e1       	ldi	r24, 0x14	; 20
    7996:	83 83       	std	Z+3, r24	; 0x03
    7998:	cf 01       	movw	r24, r30
    799a:	0e 94 b6 38 	call	0x716c	; 0x716c <HAL_SPI_Init>
    799e:	0e 94 53 3b 	call	0x76a6	; 0x76a6 <MCP2515_Rest>
    79a2:	83 e0       	ldi	r24, 0x03	; 3
    79a4:	0e 94 a7 3c 	call	0x794e	; 0x794e <MCP2515_Enable_Interrupt>
    79a8:	80 e8       	ldi	r24, 0x80	; 128
    79aa:	0e 94 83 3b 	call	0x7706	; 0x7706 <MCP2515_Set_OperMode>
    79ae:	47 e8       	ldi	r20, 0x87	; 135
    79b0:	6a ef       	ldi	r22, 0xFA	; 250
    79b2:	83 e0       	ldi	r24, 0x03	; 3
    79b4:	0e 94 70 3b 	call	0x76e0	; 0x76e0 <MCP2515_SetBitTiming>
    79b8:	21 e0       	ldi	r18, 0x01	; 1
    79ba:	40 e0       	ldi	r20, 0x00	; 0
    79bc:	50 e0       	ldi	r21, 0x00	; 0
    79be:	ba 01       	movw	r22, r20
    79c0:	80 e0       	ldi	r24, 0x00	; 0
    79c2:	0e 94 15 3c 	call	0x782a	; 0x782a <MCP2515_SetFilter>
    79c6:	21 e0       	ldi	r18, 0x01	; 1
    79c8:	40 e0       	ldi	r20, 0x00	; 0
    79ca:	50 e0       	ldi	r21, 0x00	; 0
    79cc:	ba 01       	movw	r22, r20
    79ce:	80 e0       	ldi	r24, 0x00	; 0
    79d0:	0e 94 9d 3b 	call	0x773a	; 0x773a <MCP2515_SetMask>
    79d4:	67 e0       	ldi	r22, 0x07	; 7
    79d6:	8d e0       	ldi	r24, 0x0D	; 13
    79d8:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
    79dc:	80 e0       	ldi	r24, 0x00	; 0
    79de:	0e 94 83 3b 	call	0x7706	; 0x7706 <MCP2515_Set_OperMode>
    79e2:	89 e7       	ldi	r24, 0x79	; 121
    79e4:	90 e0       	ldi	r25, 0x00	; 0
    79e6:	0e 94 49 38 	call	0x7092	; 0x7092 <EXTI_Init>
    79ea:	08 95       	ret

000079ec <MCP2515_receiveMesg>:
 * param : RecievedMesg pointer to struct that will hold all receive message information 
 * return : bool if false means their is no pending message to read   
 */

PUBLIC bool MCP2515_receiveMesg(CANMesg_t * RecievedMesg)
{
    79ec:	ef 92       	push	r14
    79ee:	ff 92       	push	r15
    79f0:	0f 93       	push	r16
    79f2:	1f 93       	push	r17
    79f4:	cf 93       	push	r28
    79f6:	df 93       	push	r29
    79f8:	7c 01       	movw	r14, r24
	uint8_t CANReaddata =0,MAilBoxNum =0,iterator=0 ;
	CANReaddata = MCP2515_Read_Register(CANINTF);
    79fa:	8c e2       	ldi	r24, 0x2C	; 44
    79fc:	0e 94 1f 3b 	call	0x763e	; 0x763e <MCP2515_Read_Register>
	if((CANReaddata & 0x01))
    7a00:	80 fd       	sbrc	r24, 0
    7a02:	04 c0       	rjmp	.+8      	; 0x7a0c <MCP2515_receiveMesg+0x20>
	{
		MAilBoxNum = 0 ;
	}
	else if((CANReaddata & 0x02)) /* means there is message is in Mailbox1 */
    7a04:	81 ff       	sbrs	r24, 1
    7a06:	5b c0       	rjmp	.+182    	; 0x7abe <MCP2515_receiveMesg+0xd2>
	{
		MAilBoxNum = 1 ;
    7a08:	d1 e0       	ldi	r29, 0x01	; 1
    7a0a:	01 c0       	rjmp	.+2      	; 0x7a0e <MCP2515_receiveMesg+0x22>
{
	uint8_t CANReaddata =0,MAilBoxNum =0,iterator=0 ;
	CANReaddata = MCP2515_Read_Register(CANINTF);
	if((CANReaddata & 0x01))
	{
		MAilBoxNum = 0 ;
    7a0c:	d0 e0       	ldi	r29, 0x00	; 0
	}
	else{
		return 0 ;
	}

	CANReaddata = MCP2515_Read_Register(CANSTAT);
    7a0e:	8e e0       	ldi	r24, 0x0E	; 14
    7a10:	0e 94 1f 3b 	call	0x763e	; 0x763e <MCP2515_Read_Register>
	RecievedMesg->CANControl.RTR_Field = (CANReaddata & 0x40)>>6 ;
    7a14:	80 74       	andi	r24, 0x40	; 64
    7a16:	90 e0       	ldi	r25, 0x00	; 0
    7a18:	08 2e       	mov	r0, r24
    7a1a:	89 2f       	mov	r24, r25
    7a1c:	00 0c       	add	r0, r0
    7a1e:	88 1f       	adc	r24, r24
    7a20:	99 0b       	sbc	r25, r25
    7a22:	00 0c       	add	r0, r0
    7a24:	88 1f       	adc	r24, r24
    7a26:	99 1f       	adc	r25, r25
    7a28:	f7 01       	movw	r30, r14
    7a2a:	94 81       	ldd	r25, Z+4	; 0x04
    7a2c:	80 fb       	bst	r24, 0
    7a2e:	95 f9       	bld	r25, 5
    7a30:	94 83       	std	Z+4, r25	; 0x04
	CANReaddata = MCP2515_Read_Register(RXBnSIDL(MAilBoxNum));
    7a32:	d2 95       	swap	r29
    7a34:	d0 7f       	andi	r29, 0xF0	; 240
    7a36:	82 e6       	ldi	r24, 0x62	; 98
    7a38:	8d 0f       	add	r24, r29
    7a3a:	0e 94 1f 3b 	call	0x763e	; 0x763e <MCP2515_Read_Register>
    7a3e:	c8 2f       	mov	r28, r24
	RecievedMesg->CANControl.EXT_Field = (CANReaddata & 0x08 )>>3 ;
    7a40:	88 70       	andi	r24, 0x08	; 8
    7a42:	90 e0       	ldi	r25, 0x00	; 0
    7a44:	95 95       	asr	r25
    7a46:	87 95       	ror	r24
    7a48:	95 95       	asr	r25
    7a4a:	87 95       	ror	r24
    7a4c:	95 95       	asr	r25
    7a4e:	87 95       	ror	r24
    7a50:	f7 01       	movw	r30, r14
    7a52:	94 81       	ldd	r25, Z+4	; 0x04
    7a54:	80 fb       	bst	r24, 0
    7a56:	94 f9       	bld	r25, 4
    7a58:	94 83       	std	Z+4, r25	; 0x04
	RecievedMesg->ID  = MCP2515_Read_Register(RXBnSIDH(MAilBoxNum));
    7a5a:	81 e6       	ldi	r24, 0x61	; 97
    7a5c:	8d 0f       	add	r24, r29
    7a5e:	0e 94 1f 3b 	call	0x763e	; 0x763e <MCP2515_Read_Register>
    7a62:	90 e0       	ldi	r25, 0x00	; 0
    7a64:	a0 e0       	ldi	r26, 0x00	; 0
    7a66:	b0 e0       	ldi	r27, 0x00	; 0
	RecievedMesg->ID  = (((uint32_t)RecievedMesg->ID<<3)|(CANReaddata>>5));
    7a68:	88 0f       	add	r24, r24
    7a6a:	99 1f       	adc	r25, r25
    7a6c:	aa 1f       	adc	r26, r26
    7a6e:	bb 1f       	adc	r27, r27
    7a70:	88 0f       	add	r24, r24
    7a72:	99 1f       	adc	r25, r25
    7a74:	aa 1f       	adc	r26, r26
    7a76:	bb 1f       	adc	r27, r27
    7a78:	88 0f       	add	r24, r24
    7a7a:	99 1f       	adc	r25, r25
    7a7c:	aa 1f       	adc	r26, r26
    7a7e:	bb 1f       	adc	r27, r27
    7a80:	c2 95       	swap	r28
    7a82:	c6 95       	lsr	r28
    7a84:	c7 70       	andi	r28, 0x07	; 7
    7a86:	8c 2b       	or	r24, r28
    7a88:	f7 01       	movw	r30, r14
    7a8a:	80 83       	st	Z, r24
    7a8c:	91 83       	std	Z+1, r25	; 0x01
    7a8e:	a2 83       	std	Z+2, r26	; 0x02
    7a90:	b3 83       	std	Z+3, r27	; 0x03
 * return : bool if false means their is no pending message to read   
 */

PUBLIC bool MCP2515_receiveMesg(CANMesg_t * RecievedMesg)
{
	uint8_t CANReaddata =0,MAilBoxNum =0,iterator=0 ;
    7a92:	c0 e0       	ldi	r28, 0x00	; 0
	RecievedMesg->CANControl.EXT_Field = (CANReaddata & 0x08 )>>3 ;
	RecievedMesg->ID  = MCP2515_Read_Register(RXBnSIDH(MAilBoxNum));
	RecievedMesg->ID  = (((uint32_t)RecievedMesg->ID<<3)|(CANReaddata>>5));
	
	
	while(iterator != 8)
    7a94:	0c c0       	rjmp	.+24     	; 0x7aae <MCP2515_receiveMesg+0xc2>
	{
		RecievedMesg->MesgData[iterator] = MCP2515_Read_Register(RXBnDm(MAilBoxNum,iterator));
    7a96:	0c 2f       	mov	r16, r28
    7a98:	10 e0       	ldi	r17, 0x00	; 0
    7a9a:	8c 2f       	mov	r24, r28
    7a9c:	8d 0f       	add	r24, r29
    7a9e:	8a 59       	subi	r24, 0x9A	; 154
    7aa0:	0e 94 1f 3b 	call	0x763e	; 0x763e <MCP2515_Read_Register>
    7aa4:	f7 01       	movw	r30, r14
    7aa6:	e0 0f       	add	r30, r16
    7aa8:	f1 1f       	adc	r31, r17
    7aaa:	85 83       	std	Z+5, r24	; 0x05
		iterator++;
    7aac:	cf 5f       	subi	r28, 0xFF	; 255
	RecievedMesg->CANControl.EXT_Field = (CANReaddata & 0x08 )>>3 ;
	RecievedMesg->ID  = MCP2515_Read_Register(RXBnSIDH(MAilBoxNum));
	RecievedMesg->ID  = (((uint32_t)RecievedMesg->ID<<3)|(CANReaddata>>5));
	
	
	while(iterator != 8)
    7aae:	c8 30       	cpi	r28, 0x08	; 8
    7ab0:	91 f7       	brne	.-28     	; 0x7a96 <MCP2515_receiveMesg+0xaa>
	{
		RecievedMesg->MesgData[iterator] = MCP2515_Read_Register(RXBnDm(MAilBoxNum,iterator));
		iterator++;
	}

	MCP2515_Write_Register(CANINTF , 0x00 ); /* FIRST CLESR FLAG */
    7ab2:	60 e0       	ldi	r22, 0x00	; 0
    7ab4:	8c e2       	ldi	r24, 0x2C	; 44
    7ab6:	0e 94 3a 3b 	call	0x7674	; 0x7674 <MCP2515_Write_Register>
	return true ;
    7aba:	81 e0       	ldi	r24, 0x01	; 1
    7abc:	01 c0       	rjmp	.+2      	; 0x7ac0 <MCP2515_receiveMesg+0xd4>
	else if((CANReaddata & 0x02)) /* means there is message is in Mailbox1 */
	{
		MAilBoxNum = 1 ;
	}
	else{
		return 0 ;
    7abe:	80 e0       	ldi	r24, 0x00	; 0
		iterator++;
	}

	MCP2515_Write_Register(CANINTF , 0x00 ); /* FIRST CLESR FLAG */
	return true ;
    7ac0:	df 91       	pop	r29
    7ac2:	cf 91       	pop	r28
    7ac4:	1f 91       	pop	r17
    7ac6:	0f 91       	pop	r16
    7ac8:	ff 90       	pop	r15
    7aca:	ef 90       	pop	r14
    7acc:	08 95       	ret

00007ace <itoa>:
    7ace:	45 32       	cpi	r20, 0x25	; 37
    7ad0:	51 05       	cpc	r21, r1
    7ad2:	20 f4       	brcc	.+8      	; 0x7adc <itoa+0xe>
    7ad4:	42 30       	cpi	r20, 0x02	; 2
    7ad6:	10 f0       	brcs	.+4      	; 0x7adc <itoa+0xe>
    7ad8:	0c 94 72 3d 	jmp	0x7ae4	; 0x7ae4 <__itoa_ncheck>
    7adc:	fb 01       	movw	r30, r22
    7ade:	10 82       	st	Z, r1
    7ae0:	cb 01       	movw	r24, r22
    7ae2:	08 95       	ret

00007ae4 <__itoa_ncheck>:
    7ae4:	bb 27       	eor	r27, r27
    7ae6:	4a 30       	cpi	r20, 0x0A	; 10
    7ae8:	31 f4       	brne	.+12     	; 0x7af6 <__itoa_ncheck+0x12>
    7aea:	99 23       	and	r25, r25
    7aec:	22 f4       	brpl	.+8      	; 0x7af6 <__itoa_ncheck+0x12>
    7aee:	bd e2       	ldi	r27, 0x2D	; 45
    7af0:	90 95       	com	r25
    7af2:	81 95       	neg	r24
    7af4:	9f 4f       	sbci	r25, 0xFF	; 255
    7af6:	0c 94 7e 3d 	jmp	0x7afc	; 0x7afc <__utoa_common>

00007afa <__utoa_ncheck>:
    7afa:	bb 27       	eor	r27, r27

00007afc <__utoa_common>:
    7afc:	fb 01       	movw	r30, r22
    7afe:	55 27       	eor	r21, r21
    7b00:	aa 27       	eor	r26, r26
    7b02:	88 0f       	add	r24, r24
    7b04:	99 1f       	adc	r25, r25
    7b06:	aa 1f       	adc	r26, r26
    7b08:	a4 17       	cp	r26, r20
    7b0a:	10 f0       	brcs	.+4      	; 0x7b10 <__utoa_common+0x14>
    7b0c:	a4 1b       	sub	r26, r20
    7b0e:	83 95       	inc	r24
    7b10:	50 51       	subi	r21, 0x10	; 16
    7b12:	b9 f7       	brne	.-18     	; 0x7b02 <__utoa_common+0x6>
    7b14:	a0 5d       	subi	r26, 0xD0	; 208
    7b16:	aa 33       	cpi	r26, 0x3A	; 58
    7b18:	08 f0       	brcs	.+2      	; 0x7b1c <__utoa_common+0x20>
    7b1a:	a9 5d       	subi	r26, 0xD9	; 217
    7b1c:	a1 93       	st	Z+, r26
    7b1e:	00 97       	sbiw	r24, 0x00	; 0
    7b20:	79 f7       	brne	.-34     	; 0x7b00 <__utoa_common+0x4>
    7b22:	b1 11       	cpse	r27, r1
    7b24:	b1 93       	st	Z+, r27
    7b26:	11 92       	st	Z+, r1
    7b28:	cb 01       	movw	r24, r22
    7b2a:	0c 94 97 3d 	jmp	0x7b2e	; 0x7b2e <strrev>

00007b2e <strrev>:
    7b2e:	dc 01       	movw	r26, r24
    7b30:	fc 01       	movw	r30, r24
    7b32:	67 2f       	mov	r22, r23
    7b34:	71 91       	ld	r23, Z+
    7b36:	77 23       	and	r23, r23
    7b38:	e1 f7       	brne	.-8      	; 0x7b32 <strrev+0x4>
    7b3a:	32 97       	sbiw	r30, 0x02	; 2
    7b3c:	04 c0       	rjmp	.+8      	; 0x7b46 <strrev+0x18>
    7b3e:	7c 91       	ld	r23, X
    7b40:	6d 93       	st	X+, r22
    7b42:	70 83       	st	Z, r23
    7b44:	62 91       	ld	r22, -Z
    7b46:	ae 17       	cp	r26, r30
    7b48:	bf 07       	cpc	r27, r31
    7b4a:	c8 f3       	brcs	.-14     	; 0x7b3e <strrev+0x10>
    7b4c:	08 95       	ret

00007b4e <eeprom_read_byte>:
    7b4e:	e1 99       	sbic	0x1c, 1	; 28
    7b50:	fe cf       	rjmp	.-4      	; 0x7b4e <eeprom_read_byte>
    7b52:	9f bb       	out	0x1f, r25	; 31
    7b54:	8e bb       	out	0x1e, r24	; 30
    7b56:	e0 9a       	sbi	0x1c, 0	; 28
    7b58:	99 27       	eor	r25, r25
    7b5a:	8d b3       	in	r24, 0x1d	; 29
    7b5c:	08 95       	ret

00007b5e <_exit>:
    7b5e:	f8 94       	cli

00007b60 <__stop_program>:
    7b60:	ff cf       	rjmp	.-2      	; 0x7b60 <__stop_program>
